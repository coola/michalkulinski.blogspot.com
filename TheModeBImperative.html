<!DOCTYPE html>

<html>
<head>

    <meta charset="UTF-8">
    <style scoped="scoped" type="text/css">
        .paragraphDiv {
            margin: 0 1em 0.5em 1em;
        }

        img {
            margin: 10px;
        }

        .cite {
            padding: 1em;
            margin: 1em;
            border-left: solid;
            border-color: #eef2f5;
        }

        .smallGreyText {
            text-align: center;
            color: #999999;
            font-size: 0.6em;
            margin: 1em 0.1em 1em 0.1em;
        }

        .code {
            font-family: monospace;
        }

    </style>

</head>
<body>

<br/>

<div class="paragraphDiv">
    Jeżeli śledzisz moje konta na <a href="https://twitter.com/unclebobmartin">twitterze</a>, <a href="https://www.facebook.com/robertcecilmartin">facebooku</a> czy
    <a href="https://github.com/unclebob?tab=repositories">githubie</a>, mogłeś zauważyć, że piszę <a
        href="https://github.com/unclebob/PDP8EmulatorIpad">emulator PDP-8 na iPada</a>.
</div>

<div class="paragraphDiv">
    Oto screenshot:

    TODO: pdp8Shot.jpg
</div>

<div class="smallGreyText">
    <hr/>
    <div>
        Poniższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina z dnia 21 lutego 2015
        ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html">https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>
<br/>

<div class="paragraphDiv">
    Moim celem napisania tego emulatora (poza zwykłą nostalgią) jest wykorzystanie go jako narzędzia szkoleniowego dla nowych programistów. Myślę, że każdy świeżo upieczony programista powinien spędzić tydzień lub dwa programując na jednej z tych starych maszyn. Wydaje mi się, że nie ma lepszego sposobu, aby zrozumieć, czym komputer tak naprawdę jest, jak tylko móc dotknąć prawdziwego komputera i móc zaprogramować go na poziomie bitów, w języku maszynowym. Jak tylko to zrobisz, cała magia zniknie i zostanie zastąpiona przez twardą, brutalną rzeczywistość. I, coś Ci powiem, programowanie PDP-8 jest
    <em>twardą, brutalną, rzeczywistością</em>. A niech mnie, jak cholera!
</div>

<div class="paragraphDiv">
    Chciałem być wierny maszynie i jej środowisku. Panel Przedni jest przyzwoitą abstrakcyjną reprezentacją oryginalnego PDP-8, i światełka zapalają się odpowiednio, i z prawidłowymi danymi. (chociaż nie mogłem się oprzeć i zrobiłem światełka wrażliwe na dotyk, tak jak w ECP-18)

    TODO : pdp8i_frontpanel.jpg
</div>

<div class="paragraphDiv">
    Papierowe taśmy w czytniku i dziurkacz poruszają się z odpowiednimi prędkościami i dziurki reprezentują prawdziwe dane. Wydają one także odpowiednie rodzaje dźwięków. Dalekopis drukuje z odpowiednią prędkościa (chociaż możesz go przyspieszyć, jeśli chcesz (będziesz chciał)) i zachowuje się mniej więcej jak
    <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">ASR-33</a>, wydając odpowiednie dźwięki, i reagując odpowiednio na znaki powrótu karetki i wysuwu wiersza, itd. (Tak, możesz naddrukować!)
</div>

<div class="paragraphDiv">
    Znalazłem jakieś binarne obrazy starego PDP-8 <a href="http://dustyoldcomputers.com/pdp-common/reference/papertapes/dec-08.html">tutaj</a>, i udało mi się  wrzucić je do mojego emulatora,
    <a href="https://en.wikipedia.org/wiki/Mung_(computer_term)">miażdżąc</a> ich format przy użyciu małego programu w C, i wrzucając je na iPada używając Dropboxa. Wynik tych działań był zarówno satysfakcjonujący jak i łapiący za serce. Starożytny kod działa!
</div>

<div class="paragraphDiv">
    Usiadłem przy klawiaturze bluetooth mojego 600 dolarowego, ćwierćkilogramowego, obudowanego w fajny pokrowiec iPada, otoczony podręcznikami programowania, i poznaczonymi listingami programu nad którym pracowałem. Uświadomiłem sobie wtedy, że pracuję nad kodem napisanym pół wieku temu, stworzonym przez mężczyzn i kobiety (prawdopodobnie w wiekszości przez kobiety w tamtych czasach), którzy zakasywali rękawy, aby sprawić, żeby ich głupiutka maszyna działała. Maszyna, która ważyła 225 kg, była rozmiaru lodówki i kosztowała 20'000$ w roku 1967.
</div>

<div class="paragraphDiv">
    Czy ktokolwiek z tych ludzi mógłby kiedykolwiek przypuszczać, że ich kod będzie odpalany na podręcznym tablecie i będzie używany do szkolenia programistów w dwudziestym pierwszym wieku? Niektórzy - wielu - może jeszcze żyć. Ciekawe co pomyśleliby, gdyby wiedzieli.

    TODO pdp8InKitchen.jpg
</div>

<div class="paragraphDiv">
    Mój emulator napisany jest w <a href="https://www.lua.org/about.html">Lua</a>, przy użyciu frameworku <a href="http://twolivesleft.com/Codea/">Codea</a> dla iPada. Jest to niezwykle wygodny język dla developmentu na iPada. Lua jest (wystarczająco) szybki, i Codea ma wspaniałe kontrolki graficzne, i prosty, acz nadal bardzo skuteczny framework do tworzenia wysoce interaktywnych programów pełnych animacji.
</div>

<div class="paragraphDiv">
    To załatwiło animację (i generowanie dźwięku) na przednim panelu, dalekopis, i czytnik/dziurkacz papieru za jednym zamachem.
</div>

<div class="paragraphDiv">
    Emulowanie bebechów PDP-8 staje się niezłym wyzwaniem odkąd Lua ma tylko jeden typ numeryczny: zmiennoprzecinkowy. Tworzenie 12 bitowej logiki przy użyciu li tylko matematyki zmiennoprzecinkowej, jest, hmmm, <em>interesujące</em>. Z drugiej strony, miałem niezłą frajdę z oglądania FOCAL(FORmula CALculator: języka podobnego do Basica) odpalonego na moim PDP-8, dokonującego obliczeń zmiennoprzecinkowych, używając operacji logicznych, które to z kolei wymyśliłem przy użyciu matematyki zmiennoprzecinkowej LUA.
    <span class="code">&ltuśmiech&gt</span> Powinieneś był zobaczyć, jak te światełka mrugały!
</div>

<div class="paragraphDiv">
    Prędkość uruchomieniowa to około 4000 instrukcji na sekundę. Mimo, że to tylko 1/7 prędkości PDP-8/S, było to całkiem imponujące jak na iPada wykonywującego język "interpretowanego byte-codu" taki jak Lua, emulującego 12-bitową logikę przy użyciu obliczeń zmiennoprzecionkowych! Nie spodziewałem się takiej szybkości. W zasadzie odpala cały ten stary software firmy
    <a href="https://pl.wikipedia.org/wiki/Digital_Equipment_Corporation">DEC</a> z sensowną prędkością. Nawet <span
        class="code">FOCAL</span> działa wystarczająco szybko do obliczania pierwiastków kwadratowych w coś koło pół sekundy.
</div>

<div class="paragraphDiv">
    I, znowu, te mruganie światełek podczas kompilacji jest bardzo przyjemne. Tylko popatrz, a od razu odkryjesz, czym były inspirowane filmy science-fiction z lat 50-tych XX. wieku.
</div>

<div class="paragraphDiv">
<h2>TRYB-B</h2>
</div>

<div class="paragraphDiv">
    Sprawienie, aby kompilator działał było naprawdę bardzo łatwe. Prawdopodobnie spędziłem nad tym w całości 30 godzin; i to włącznie z uczeniem się Codea i Lua.
</div>

<div class="paragraphDiv">
    Proces developmentu pędził jak szalony. Edytor Lua w Codea dla iPada jest potężyny i intuicyjny (chociaż nie ma refaktoringów
    <span class="code">&ltchlip&gt</span>). Pętla edycji/stestowania trwała, może, 10 sekund. Mogłem dodać linie, czy dwie, odpalić appkę, zobaczyć efekt, wskoczyć z powrotem do edytora ot tak. To była przyjemne udogodnienie i miałem przy tym niezłą zabawę.
</div>

<div class="paragraphDiv">
    Oczywiście napisałem testy do trudniejszych kawałków. Napisałem mały framework testowy, tylko do tego celu, i dodałem przycisk
    <span class="code">TEST</span> na panelu przednim emulatora, aby ułatwić sobie odpalanie tych testów. Kod emulacji sam w sobie byłby prawie niemożliwy do napisania, gdybym nie miał tych testów. I, oczywiście, korzystałem z dyscypliny TDD przy pisaniu tego kodu. Koniec końców powstało ponad 100 testów dla najróżniejszych instrukcji i zachowań komputera PDP-8.
</div>

<div class="paragraphDiv">
    Dla GUI, z drugiej strony (i było tam mnóstwo kodu GUI), testy były niepotrzebne(<span class="code">&ltoch&gt</span>). Moje oczy były testami. Wiedziałem, co chcę zobaczyć, więc rozkręciłem 10-sekundową pętlę edytuj/stestuj. Pisanie testów w stylu TDD byłoby okropnie trudne, i stałyby się całkowitą stratą czasu.
</div>

<div class="paragraphDiv">
    Z drugiej strony, to był nadal <em>rytm</em> TDD. Wiedziałem, co chcę zobaczyć na ekranie. To był mój test. Po prostu zmodyfikowałem kod zanim test został spełniony. A więc nawet jeśli nie pisałem testów, czułem się tak, jakbym pisał -
    <em>czułem się, jak podczas TDD</em>.
</div>

<div class="paragraphDiv">
    Oczywiście to prawda, że nie miałem zautomatyzowanych testów regresji dla mojego GUI. Z drugiej strony upewnienie się czy wszystko działa było absurdalnie proste. W ten sposób brak zautomatyzowanych testów GUI nie wpłynął na czas trwania mojej pętli.
</div>

<div class="paragraphDiv">
    Oczywiście, bez narzędzi do refaktoringu kod zrobił się trochę zabałaganiony. Zrefaktorowałem to, czego nie mogłem znieść; ale rozmiar zabałagacenia jest większy niżbym chciał. Uda mi się sprzątnąć ten kod; ale dużo wolniej pracuje się bez dobrych narzędzi do refaktoringu.
</div>

<div class="paragraphDiv">
    Tym nie mnie, na potrzeby tego artykułu, nazwijmy ten styl programowania: <span class="code">TRYB-B</span>. <span
        class="code">TRYB-B</span> jest stylem, który pozwala Ci jednocześnie edytować coś na ekranie i widzieć na tym ekranie skutki, lub test, który przechodzi, w ciągu kilku sekund. To development o prędkości światła, który nie wymaga listingów, ołówków, czasu kompilacji, czasu poświęconego na ustawienie, lub żadnego innego utrudnienia. Czas pomiędzy edytowaniem kodu, a oglądaniem go działającego jest dużo mniejszy niż jedna minuta.
</div>

<div class="paragraphDiv">
<h2>TRYB-A</h2>
</div>

<div class="paragraphDiv">
    Mając działający Emulator PDP-8, i mając te wszystkie stare narzędzia takie, jak edytor taśmy papierowej, i działający assembler Pal-3, zabrałem się za pisanie prostego programu. Ten program pozwoliłby użytkownikoi wpisać prostą formułę na klawiaturze, i wtedy wyświetliłby wynik. Dla przykładu, jeśli użytkownik wpisałby:
    <span class="code">25+32</span>, komputer wyświetliłby
    <span class="code">57</span>.
</div>

<div class="paragraphDiv">
    Na PDP-8 to nie jest trywialny program. Zamieściłem go poniżej dla tych z Was, którzy chcieliby zobaczyć, jak biedni programiści PDP-8 musieli to pisać.
</div>


<div class="paragraphDiv">
    Proces był taki sam jak proces, którego używałem w późnych latach 70-tych XX. wieku kiedy pracowałem nad assemblerowymi programami w na Teradyne M365 (18-bitowy kuzyn PDP-8). Mieliśmy taśmę magnetyczną, zamiast taśmy papierowej; i komputer był troszkę potężniejszy obliczeniowo niż PDP-8. Ale proces pozostawał taki sam. A leciało to tak:
</div>

<div class="paragraphDiv">
    Załóżmy, że jesteś w środku pisania tego programu poniżej. Już trochę napisałeś, i chcesz coś jeszcze dodać. Pamiętaj, ten komputer posiada słowa o długości tylko
    <span class="code">4K</span>. Nie może przechowywać wiele w swojej pamięci. Pamiętaj o tym, że jedynym magazynem pamięci masowej, którym dysponujesz jest papierowa taśma. Także twój kod źródłowy jest na tym samym długim pasku tej samej papierowej taśmy.
</div>

<div class="paragraphDiv">
    <ol>
        <li>
            Zapisujesz zmiany jakie chcesz wprowadzić do programu na aktualnym listingu. Będziesz miał zmiany na wielu stronach, więc wepnij spinacze biurowe na każdą ze stron, jeśli listing jest długi.
        </li>
        <li>Załaduj edytor z taśmy papierowej. To zajmie kilka minut, więc zrób sobię kawę.</li>
        <li>Ustaw przełączniki na panelu przednim na <span class="code">6003</span>: dla kompresji spacji, i użyj czytnika/dziurkacza wysokiej prędkości. Uruchom edytor (poprzez ustawienie <span class="code">0200</span> na rejestrach PC i naciśnięcie klawisza
            <span class="code">RUN</span>)</li>
        <li>Włóż papierową taśmę z twoim kodem źródłowym do czytnika</li>
        <li>Wczytaj jedną "stronę" kodu z papierowej taśmy używając komendy <span class="code">R</span>. (50 linii lub mniej. 1 minuta lub więcej).</li>
        <li>Idź do tej strony w twoim listingu i nanieś poprawki używając komend <span class="code">I</span>, <span
                class="code">C</span> i <span class="code">D</span>. Pamiętaj, że nie masz ekranu, więc edytujesz linia po linii, używając numerów linii. Zaplanuj spędzić nad tym trochę czasu.</li>
        <li>Wydrukuj aktualną stronę używając komendy <span class="code">L</span>. Upewnij się, że wszystkie zmiany są poprawne.</li>
        <li>Wydziurkuj aktualną stronę na papierową taśmę używając komendy P. (minuta lub więcej).</li>
        <li>Wydziurkuj aktualną stronę i następnie ją wczytaj używając komendy <span class="code">N</span> i jeżeli to nie była ostatnia strona idź do punktu 6.</li>
        <li>Wyjmij nową taśmę z kodem źródłowym z dziurkacza i oznacz ją tytułem i numerem wersji. <em>Nigdy nie
            zapomnij o numerze wersji!</em></li>
        <li>Załaduj assembler do pamieci za papierowej taśmy (10 minut lub więcej).</li>
        <li>Ustaw przełącznik na panelu przednim na <span class="code">2002</span>: to konfiguracja "przejście pierwsze, wyjście na drukarkę".</li>
        <li>Załaduj źródłową taśmę do czytnika</li>
        <li>Załaduj <span class="code">0200</span> do rejestru PC, i wciśnij <span class="code">RUN</span>.</li>
        <li>Kompilacja przejście pierwsze wczyta całą taśmę z kodem źródłowym i wydrukuje tablicę symboli. (10 minut albo więcej).</li>
        <li>Gdy komputer się zatrzyma, ustaw na panelu przednim przełączniki na <span class="code">4003</span>: konfiguracja "przejście drugie, wyjście na dziurkacz".</li>
        <li>Załaduj twój kod źródłowy do czytnika</li>
        <li>Wciśnij <span class="code">RUN</span>. Kompilacja przejście drugie wczyta całą twoją taśmę źródłową i wydziurkuje twoją binarną papierową taśmę. (15 minut albo więcej). Błędy w kodzie źródłowym wydrukują się podczas tego przejścia.</li>
        <li>Gdy komputer się zatrzyma, jeśli były jakieś błędy, wyrzuć papierową taśmę, która była przed chwilą dziurkowana i przejdź do punktu 1. Jeśli nie było wyjmij taśmę binarną z dziurkacza i oznacz ją tytułem i numerem wersji. (Nie muszę Ci już przypominać o numerze wersji, prawda?)</li>
        <li>Ustaw przełączniki na panelu przednim na <span class="code">6002</span>: to konfiguracja "przejście trzecie, wyjście na drukarkę".</li>
        <li>Włóż twoją źródłową taśmę do czytnika</li>
        <li>Wciśnij <span class="code">RUN</span>. Kompilacja przejścia trzeciego wczyta całą taśmę z kodem źródłowym i wydrukuje listing programu. Będziesz potrzebował jej do debuugowania, więc nie zlekceważ tego. (30 minut albo więcej ponieważ drukarka jest bardzo wolna). Upewnij się, że masz wystarczająco dużo papieru w drukarce!</li>
        <li>Oderwij listing i go sprawdź.</li>
        <li>Włóż swoją taśmę binarną do czytnika.</li>
        <li>Ustaw rejestry PC na <span class="code">7777</span> (adres ładowarki binarnej, która zwykle jest przechowywana w pamięci rdzenia) i naciśnij <span class="code">RUN</span>. Jeżeli w pamięci, z jakiegoś powodu, nie ma ładowarki binarnej, musisz przestawić się w tryb ładowarki
            <span class="code">RIM</span> i wczytać przed tym krokiem ładowarkę binarną z papierowej taśmy .</li>
        <li>Gdy komputer się zatrzyma, twój program jest wczytany do pamięci. Uruchom go i zobacz jak działa.</li>
    </ol>
</div>

<div class="paragraphDiv">
    Ten proces jest bardzo skrócony. Jest tam jeszcze mnóstwo drobniejszych kroków, ale myślę, że masz już pełny obraz.
</div>

<div class="paragraphDiv">
    To jest <span class="code">TRYB-A</span>. To jest bardzo delikatny, podatny na błędy proces, którego przeprowadzenie zajmuje godzinę lub więcej. Może być jeszcze więcej dla większych programów. Bardzo mały program robi z tej pętli około 15 minut. Program, który pisałem, urósł do około 20-30 minut lub więcej, i oszukiwałem pozwalając mojemu dalekopisowi działać z prędkością 10 razy większą niż normalna prędkość.
</div>

<div class="paragraphDiv">
    Żeby zmusić mój mały śmieszny program do działania, szedłem tą pętlą siedem razy. Zabrało mi to około tygodnia, i łącznie około pieciu godzin. Wiele z tego było
    <em>pisaniem kodu z użyciem ołówka</em>, ponieważ bez edytora na ekranie, nie było możliwości ominąć ręcznego pisania, i używania gumki do ścierania bez przerwy.
</div>

<div class="paragraphDiv">
    W latach 70-tych spędzałem dni, tygodnie, i lata na pracy w <span class="code">TRYBIE-A</span>. Wszyscy programiści spędzali. Tak właśnie wtedy wyglądało programowanie.
</div>

<div class="paragraphDiv">
    Jest jedna sprawa, jeśli chodzi o <span class="code">TRYB-A</span>: MUSISZ BYĆ OSTROŻNY. Każdy błąd kosztuje cię godzinę lub więcej. Więc spędzasz mnóstwo czasu ogarniająć szczegóły, upewniając się, że kod jest dobry; że wyedytowałeś go odpowiednio; że przełączniki są ustawione właściwie; że taśmy są opisane poprawnie; etc
</div>

<div class="paragraphDiv">
    W <span class="code">TRYBIE-A</span> nie bierzesz <em>niczego</em> za pewnik. Robisz wszystko <em>rozmyślnie</em> i <em>ostrożnie</em>. Ponieważ to jedyna droga abyś robił to szybko. (Jeśli "szybko" jest w tym przypadku dobrym słowem.)
</div>

<div class="paragraphDiv">
    Nazwijmy tę rozwagę i ostrożność: zachowaniem <span class="code">TRYBU-A</span>
</div>

<div class="paragraphDiv">
    <h2>TRYB-A kontra TRYB-B</h2>
</div>

<div class="paragraphDiv">
    <span class="code">TRYB-A</span> jest o wiele wolniejszy niż <span class="code">TRYB-B</span>. Czas pętli jest niemożliwie długi, zakres funkcjonalności, którą udaje Ci się stworzyć w ciągu każdej pętli jest śmiesznie mały. Dla przykładu, podczas mojej pierwszej pętli w tym procesie napisałem i zdebbugowałem podprogram, który wczytywał linię tekstu z klawiatury, zakończonej znakiem CR (<a
        href="https://pl.wikipedia.org/wiki/CRLF">
    Carriage Return - Powrót Karetki</a>... Tak, dalekopis miał "karetkę", lub raczej "głowicę drukującą", która mogła "powrócić".)
</div>

<div class="paragraphDiv">
    <span class="code">TRYB-B</span> z kolei jest szybki! Naprawdę, naprawdę szybki. Czas pętli jest bardzo krótki, i możesz zrobić o wiele więcej w każdej pętli. Dla przykładu, zabrało mi tylko kilka pętli, żeby zrobić poprawnie animację przechodzenia papierowej taśmy przez czytnik i dziurkacz. Każda maszynowa instrukcja PDP-8 zabrała mi pętlę lub dwie. Sprawienie, aby przesuwał się papier w
    <a href="https://pl.wikipedia.org/wiki/Dalekopis">TTY</a> zajęło mi dwie lub trzy pętle.
</div>

<div class="paragraphDiv">
    No i, oczywiście, nie używałem listingów. Nie pisałem kodu najpierw na papierze. Mogłem pójść gdziekolwiek gdzie chciałem w programie i wyedytować dowolną linię jaką chciałem w mgnieniu oka. Miałem
    <a href="https://pl.wikipedia.org/wiki/Pod%C5%9Bwietlanie_sk%C5%82adni">podświetlanie składni</a>, automatyczne wcięcia, znajdź i zamień, skrollowanie, zakładki, i dokumentację na Internecie.
</div>

<div class="paragraphDiv">
    <span class="code">Tryb-B</span> jest szybki!
</div>

<div class="paragraphDiv">
    <h2>Konieczność TRYBU-B</h2>
</div>

<div class="paragraphDiv">
    Więc dlaczego jeszcze tak wielu programistów wciąż pracuje w TRYBIE-A? Robią to, wiecie. Wrzucają jedną kupę śmieci do na drugą, i framework na framework, aż ich czas pętli rośnie z sekund do minut i dłużej?
</div>

<!---------- -->
<div class="paragraphDiv">
</div>

<div class="smallGreyText">
    <hr/>
    <div>
        Powyższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina z dnia 21 lutego 2015
        ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html">https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>


</body>

</html>