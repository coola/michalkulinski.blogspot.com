<!DOCTYPE html>

<html>
<head>

    <meta charset="UTF-8">
    <style scoped="scoped" type="text/css">
        .paragraphDiv {
            margin: 0 1em 0.5em 1em;
        }

        img {
            margin: 10px;
        }

        .cite {
            padding: 1em;
            margin: 1em;
            border-left: solid;
            border-color: #eef2f5;
        }

        .smallGreyText {
            text-align: center;
            color: #999999;
            font-size: 0.6em;
            margin: 1em 0.1em 1em 0.1em;
        }

        .code {
            font-family: monospace;
        }

    </style>

</head>
<body>

<br/>

<div class="paragraphDiv">
    Jeżeli śledzisz moje konta na <a href="https://twitter.com/unclebobmartin">twitterze</a>, <a href="https://www.facebook.com/robertcecilmartin">facebooku</a> czy
    <a href="https://github.com/unclebob?tab=repositories">githubie</a>, mogłeś zauważyć, że piszę <a
        href="https://github.com/unclebob/PDP8EmulatorIpad">emulator PDP-8 na iPada</a>.
</div>

<div class="paragraphDiv">
    Oto screenshot:

    TODO: pdp8Shot.jpg
</div>

<div class="smallGreyText">
    <hr/>
    <div>
        Poniższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina z dnia 21 lutego 2015
        ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html">https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>
<br/>

<div class="paragraphDiv">
    Moim celem napisania tego emulatora (poza zwykłą nostalgią) jest wykorzystanie go jako narzędzia szkoleniowego dla nowych programistów. Myślę, że każdy świeżo upieczony programista powinien spędzić tydzień lub dwa programując na jednej z tych starych maszyn. Wydaje mi się, że nie ma lepszego sposobu, aby zrozumieć, czym komputer tak naprawdę jest, jak tylko móc dotknąć prawdziwego komputera i móc zaprogramować go na poziomie bitów, w języku maszynowym. Jak tylko to zrobisz, cała magia zniknie i zostanie zastąpiona przez twardą, brutalną rzeczywistość. I, coś Ci powiem, programowanie PDP-8 jest
    <em>twardą, brutalną, rzeczywistością</em>. A niech mnie, jak cholera!
</div>

<div class="paragraphDiv">
    Chciałem być wierny maszynie i jej środowisku. Panel Przedni jest przyzwoitą abstrakcyjną reprezentacją oryginalnego PDP-8, i światełka zapalają się odpowiednio, i z prawidłowymi danymi. (chociaż nie mogłem się oprzeć i zrobiłem światełka wrażliwe na dotyk, tak jak w ECP-18)

    TODO : pdp8i_frontpanel.jpg
</div>

<div class="paragraphDiv">
    Papierowe taśmy w czytniku i dziurkacz poruszają się z odpowiednimi prędkościami i dziurki reprezentują prawdziwe dane. Wydają one także odpowiednie rodzaje dźwięków. Dalekopis drukuje z odpowiednią prędkościa (chociaż możesz go przyspieszyć, jeśli chcesz (będziesz chciał)) i zachowuje się mniej więcej jak
    <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">ASR-33</a>, wydając odpowiednie dźwięki, i reagując odpowiednio na znaki powrótu karetki i wysuwu wiersza, itd. (Tak, możesz naddrukować!)
</div>

<div class="paragraphDiv">
    Znalazłem jakieś binarne obrazy starego PDP-8 <a href="http://dustyoldcomputers.com/pdp-common/reference/papertapes/dec-08.html">tutaj</a>, i udało mi się  wrzucić je do mojego emulatora,
    <a href="https://en.wikipedia.org/wiki/Mung_(computer_term)">miażdżąc</a> ich format przy użyciu małego programu w C, i wrzucając je na iPada używając Dropboxa. Wynik tych działań był zarówno satysfakcjonujący jak i łapiący za serce. Starożytny kod działa!
</div>

<div class="paragraphDiv">
    Usiadłem przy klawiaturze bluetooth mojego 600 dolarowego, ćwierćkilogramowego, obudowanego w fajny pokrowiec iPada, otoczony podręcznikami programowania, i poznaczonymi listingami programu nad którym pracowałem. Uświadomiłem sobie wtedy, że pracuję nad kodem napisanym pół wieku temu, stworzonym przez mężczyzn i kobiety (prawdopodobnie w wiekszości przez kobiety w tamtych czasach), którzy zakasywali rękawy, aby sprawić, żeby ich głupiutka maszyna działała. Maszyna, która ważyła 225 kg, była rozmiaru lodówki i kosztowała 20'000$ w roku 1967.
</div>

<div class="paragraphDiv">
    Czy ktokolwiek z tych ludzi mógłby kiedykolwiek przypuszczać, że ich kod będzie odpalany na podręcznym tablecie i będzie używany do szkolenia programistów w dwudziestym pierwszym wieku? Niektórzy - wielu - może jeszcze żyć. Ciekawe co pomyśleliby, gdyby wiedzieli.

    TODO pdp8InKitchen.jpg
</div>

<div class="paragraphDiv">
    Mój emulator napisany jest w <a href="https://www.lua.org/about.html">Lua</a>, przy użyciu frameworku <a href="http://twolivesleft.com/Codea/">Codea</a> dla iPada. Jest to niezwykle wygodny język dla developmentu na iPada. Lua jest (wystarczająco) szybki, i Codea ma wspaniałe kontrolki graficzne, i prosty, acz nadal bardzo skuteczny framework do tworzenia wysoce interaktywnych programów pełnych animacji.
</div>

<div class="paragraphDiv">
    To załatwiło animację (i generowanie dźwięku) na przednim panelu, dalekopis, i czytnik/dziurkacz papieru za jednym zamachem.
</div>

<div class="paragraphDiv">
    Emulowanie bebechów PDP-8 staje się niezłym wyzwaniem odkąd Lua ma tylko jeden typ numeryczny: zmiennoprzecinkowy. Tworzenie 12 bitowej logiki przy użyciu li tylko matematyki zmiennoprzecinkowej, jest, hmmm, <em>interesujące</em>. Z drugiej strony, miałem niezłą frajdę z oglądania FOCAL(FORmula CALculator: języka podobnego do Basica) odpalonego na moim PDP-8, dokonującego obliczeń zmiennoprzecinkowych, używając operacji logicznych, które to z kolei wymyśliłem przy użyciu matematyki zmiennoprzecinkowej LUA.
    <span class="code">&ltuśmiech&gt</span> Powinieneś był zobaczyć, jak te światełka mrugały!
</div>

<div class="paragraphDiv">
    Prędkość uruchomieniowa to około 4000 instrukcji na sekundę. Mimo, że to tylko 1/7 prędkości PDP-8/S, było to całkiem imponujące jak na iPada wykonywującego język "interpretowanego byte-codu" taki jak Lua, emulującego 12-bitową logikę przy użyciu obliczeń zmiennoprzecionkowych! Nie spodziewałem się takiej szybkości. W zasadzie odpala cały ten stary software firmy
    <a href="https://pl.wikipedia.org/wiki/Digital_Equipment_Corporation">DEC</a> z sensowną prędkością. Nawet <span
        class="code">FOCAL</span> działa wystarczająco szybko do obliczania pierwiastków kwadratowych w coś koło pół sekundy.
</div>

<div class="paragraphDiv">
    I, znowu, te mruganie światełek podczas kompilacji jest bardzo przyjemne. Tylko popatrz, a od razu odkryjesz, czym były inspirowane filmy science-fiction z lat 50-tych XX. wieku.
</div>

<div class="paragraphDiv">
<h2>TRYB-B</h2>
</div>

<div class="paragraphDiv">
    Sprawienie, aby kompilator działał było naprawdę bardzo łatwe. Prawdopodobnie spędziłem nad tym w całości 30 godzin; i to włącznie z uczeniem się Codea i Lua.
</div>

<div class="paragraphDiv">
    Proces developmentu pędził jak szalony. Edytor Lua w Codea dla iPada jest potężyny i intuicyjny (chociaż nie ma refaktoringów
    <span class="code">&ltchlip&gt</span>). Pętla edycji/stestowania trwała, może, 10 sekund. Mogłem dodać linie, czy dwie, odpalić appkę, zobaczyć efekt, wskoczyć z powrotem do edytora ot tak. To była przyjemne udogodnienie i miałem przy tym niezłą zabawę.
</div>

<div class="paragraphDiv">
    Oczywiście napisałem testy do trudniejszych kawałków. Napisałem mały framework testowy, tylko do tego celu, i dodałem przycisk
    <span class="code">TEST</span> na panelu przednim emulatora, aby ułatwić sobie odpalanie tych testów. Kod emulacji sam w sobie byłby prawie niemożliwy do napisania, gdybym nie miał tych testów. I, oczywiście, korzystałem z dyscypliny TDD przy pisaniu tego kodu. Koniec końców powstało ponad 100 testów dla najróżniejszych instrukcji i zachowań komputera PDP-8.
</div>

<div class="paragraphDiv">
    Dla GUI, z drugiej strony (i było tam mnóstwo kodu GUI), testy były niepotrzebne(<span class="code">&ltoch&gt</span>). Moje oczy były testami. Wiedziałem, co chcę zobaczyć, więc rozkręciłem 10-sekundową pętlę edytuj/stestuj. Pisanie testów w stylu TDD byłoby okropnie trudne, i stałyby się całkowitą stratą czasu.
</div>

<div class="paragraphDiv">
    Z drugiej strony, to był nadal <em>rytm</em> TDD. Wiedziałem, co chcę zobaczyć na ekranie. To był mój test. Po prostu zmodyfikowałem kod zanim test został spełniony. A więc nawet jeśli nie pisałem testów, czułem się tak, jakbym pisał -
    <em>czułem się, jak podczas TDD</em>.
</div>

<div class="paragraphDiv">
    Oczywiście to prawda, że nie miałem zautomatyzowanych testów regresji dla mojego GUI. Z drugiej strony upewnienie się czy wszystko działa było absurdalnie proste. W ten sposób brak zautomatyzowanych testów GUI nie wpłynął na czas trwania mojej pętli.
</div>

<div class="paragraphDiv">
    Oczywiście, bez narzędzi do refaktoringu kod zrobił się trochę zabałaganiony. Zrefaktorowałem to, czego nie mogłem znieść; ale rozmiar zabałagacenia jest większy niżbym chciał. Uda mi się sprzątnąć ten kod; ale dużo wolniej pracuje się bez dobrych narzędzi do refaktoringu.
</div>

<div class="paragraphDiv">
    Tym nie mnie, na potrzeby tego artykułu, nazwijmy ten styl programowania: <span class="code">TRYB-B</span>. <span
        class="code">TRYB-B</span> jest stylem, który pozwala Ci jednocześnie edytować coś na ekranie i widzieć na tym ekranie skutki, lub test, który przechodzi, w ciągu kilku sekund. To development o prędkości światła, który nie wymaga listingów, ołówków, czasu kompilacji, czasu poświęconego na ustawienie, lub żadnego innego utrudnienia. Czas pomiędzy edytowaniem kodu, a oglądaniem go działającego jest dużo mniejszy niż jedna minuta.
</div>

<div class="paragraphDiv">
<h2>TRYB-A</h2>
</div>

<div class="paragraphDiv">
    Mając działający Emulator PDP-8, i mając te wszystkie stare narzędzia takie, jak edytor taśmy papierowej, i działający assembler Pal-3, zabrałem się za pisanie prostego programu. Ten program pozwoliłby użytkownikoi wpisać prostą formułę na klawiaturze, i wtedy wyświetliłby wynik. Dla przykładu, jeśli użytkownik wpisałby:
    <span class="code">25+32</span>, komputer wyświetliłby
    <span class="code">57</span>.
</div>

<div class="paragraphDiv">
    Na PDP-8 to nie jest trywialny program. Zamieściłem go poniżej dla tych z Was, którzy chcieliby zobaczyć, jak biedni programiści PDP-8 musieli to pisać.
</div>


<div class="paragraphDiv">
    Proces był taki sam jak proces, którego używałem w późnych latach 70-tych XX. wieku kiedy pracowałem nad assemblerowymi programami w na Teradyne M365 (18-bitowy kuzyn PDP-8). Mieliśmy taśmę magnetyczną, zamiast taśmy papierowej; i komputer był troszkę potężniejszy obliczeniowo niż PDP-8. Ale proces pozostawał taki sam. A leciało to tak:
</div>

<div class="paragraphDiv">
    Załóżmy, że jesteś w środku pisania tego programu poniżej. Już trochę napisałeś, i chcesz coś jeszcze dodać. Pamiętaj, ten komputer posiada słowa o długości tylko
    <span class="code">4K</span>. Nie może przechowywać wiele w swojej pamięci. Pamiętaj o tym, że jedynym magazynem pamięci masowej, którym dysponujesz jest papierowa taśma. Także twój kod źródłowy jest na tym samym długim pasku tej samej papierowej taśmy.
</div>

<div class="paragraphDiv">
    <ol>
        <li>
            Zapisujesz zmiany jakie chcesz wprowadzić do programu na aktualnym listingu. Będziesz miał zmiany na wielu stronach, więc wepnij spinacze biurowe na każdą ze stron, jeśli listing jest długi.
        </li>
        <li>Załaduj edytor z taśmy papierowej. To zajmie kilka minut, więc zrób sobię kawę.</li>
        <li>Ustaw przełączniki na panelu przednim na <span class="code">6003</span>: dla kompresji spacji, i użyj czytnika/dziurkacza wysokiej prędkości. Uruchom edytor (poprzez ustawienie <span class="code">0200</span> na rejestrach PC i naciśnięcie klawisza
            <span class="code">RUN</span>)</li>
        <li>Włóż papierową taśmę z twoim kodem źródłowym do czytnika</li>
        <li>Wczytaj jedną "stronę" kodu z papierowej taśmy używając komendy <span class="code">R</span>. (50 linii lub mniej. 1 minuta lub więcej).</li>
        <li>Idź do tej strony w twoim listingu i nanieś poprawki używając komend <span class="code">I</span>, <span
                class="code">C</span> i <span class="code">D</span>. Pamiętaj, że nie masz ekranu, więc edytujesz linia po linii, używając numerów linii. Zaplanuj spędzić nad tym trochę czasu.</li>
        <li>Wydrukuj aktualną stronę używając komendy <span class="code">L</span>. Upewnij się, że wszystkie zmiany są poprawne.</li>
        <li>Wydziurkuj aktualną stronę na papierową taśmę używając komendy P. (minuta lub więcej).</li>
        <li>Wydziurkuj aktualną stronę i następnie ją wczytaj używając komendy <span class="code">N</span> i jeżeli to nie była ostatnia strona idź do punktu 6.</li>
        <li>Wyjmij nową taśmę z kodem źródłowym z dziurkacza i oznacz ją tytułem i numerem wersji. <em>Nigdy nie
            zapomnij o numerze wersji!</em></li>
        <li>Załaduj assembler do pamieci za papierowej taśmy (10 minut lub więcej).</li>
        <li>Ustaw przełącznik na panelu przednim na <span class="code">2002</span>: to konfiguracja "przejście pierwsze, wyjście na drukarkę".</li>
        <li>Załaduj źródłową taśmę do czytnika</li>
        <li>Załaduj <span class="code">0200</span> do rejestru PC, i wciśnij <span class="code">RUN</span>.</li>
        <li>Kompilacja przejście pierwsze wczyta całą taśmę z kodem źródłowym i wydrukuje tablicę symboli. (10 minut albo więcej).</li>
        <li>Gdy komputer się zatrzyma, ustaw na panelu przednim przełączniki na <span class="code">4003</span>: konfiguracja "przejście drugie, wyjście na dziurkacz".</li>
        <li>Załaduj twój kod źródłowy do czytnika</li>
        <li>Wciśnij <span class="code">RUN</span>. Kompilacja przejście drugie wczyta całą twoją taśmę źródłową i wydziurkuje twoją binarną papierową taśmę. (15 minut albo więcej). Błędy w kodzie źródłowym wydrukują się podczas tego przejścia.</li>
        <li>Gdy komputer się zatrzyma, jeśli były jakieś błędy, wyrzuć papierową taśmę, która była przed chwilą dziurkowana i przejdź do punktu 1. Jeśli nie było wyjmij taśmę binarną z dziurkacza i oznacz ją tytułem i numerem wersji. (Nie muszę Ci już przypominać o numerze wersji, prawda?)</li>
        <li>Ustaw przełączniki na panelu przednim na <span class="code">6002</span>: to konfiguracja "przejście trzecie, wyjście na drukarkę".</li>
        <li>Włóż twoją źródłową taśmę do czytnika</li>
        <li>Wciśnij <span class="code">RUN</span>. Kompilacja przejścia trzeciego wczyta całą taśmę z kodem źródłowym i wydrukuje listing programu. Będziesz potrzebował jej do debuugowania, więc nie zlekceważ tego. (30 minut albo więcej ponieważ drukarka jest bardzo wolna). Upewnij się, że masz wystarczająco dużo papieru w drukarce!</li>
        <li>Oderwij listing i go sprawdź.</li>
        <li>Włóż swoją taśmę binarną do czytnika.</li>
        <li>Ustaw rejestry PC na <span class="code">7777</span> (adres ładowarki binarnej, która zwykle jest przechowywana w pamięci rdzenia) i naciśnij <span class="code">RUN</span>. Jeżeli w pamięci, z jakiegoś powodu, nie ma ładowarki binarnej, musisz przestawić się w tryb ładowarki
            <span class="code">RIM</span> i wczytać przed tym krokiem ładowarkę binarną z papierowej taśmy .</li>
        <li>Gdy komputer się zatrzyma, twój program jest wczytany do pamięci. Uruchom go i zobacz jak działa.</li>
    </ol>
</div>

<div class="paragraphDiv">
    Ten proces jest bardzo skrócony. Jest tam jeszcze mnóstwo drobniejszych kroków, ale myślę, że masz już pełny obraz.
</div>

<div class="paragraphDiv">
    To jest <span class="code">TRYB-A</span>. To jest bardzo delikatny, podatny na błędy proces, którego przeprowadzenie zajmuje godzinę lub więcej. Może być jeszcze więcej dla większych programów. Bardzo mały program robi z tej pętli około 15 minut. Program, który pisałem, urósł do około 20-30 minut lub więcej, i oszukiwałem pozwalając mojemu dalekopisowi działać z prędkością 10 razy większą niż normalna prędkość.
</div>

<div class="paragraphDiv">
    Żeby zmusić mój mały śmieszny program do działania, szedłem tą pętlą siedem razy. Zabrało mi to około tygodnia, i łącznie około pieciu godzin. Wiele z tego było
    <em>pisaniem kodu z użyciem ołówka</em>, ponieważ bez edytora na ekranie, nie było możliwości ominąć ręcznego pisania, i używania gumki do ścierania bez przerwy.
</div>

<div class="paragraphDiv">
    W latach 70-tych spędzałem dni, tygodnie, i lata na pracy w <span class="code">TRYBIE-A</span>. Wszyscy programiści spędzali. Tak właśnie wtedy wyglądało programowanie.
</div>

<div class="paragraphDiv">
    Jest jedna sprawa, jeśli chodzi o <span class="code">TRYB-A</span>: MUSISZ BYĆ OSTROŻNY. Każdy błąd kosztuje cię godzinę lub więcej. Więc spędzasz mnóstwo czasu ogarniająć szczegóły, upewniając się, że kod jest dobry; że wyedytowałeś go odpowiednio; że przełączniki są ustawione właściwie; że taśmy są opisane poprawnie; etc
</div>

<div class="paragraphDiv">
    W <span class="code">TRYBIE-A</span> nie bierzesz <em>niczego</em> za pewnik. Robisz wszystko <em>rozmyślnie</em> i <em>ostrożnie</em>. Ponieważ to jedyna droga abyś robił to szybko. (Jeśli "szybko" jest w tym przypadku dobrym słowem.)
</div>

<div class="paragraphDiv">
    Nazwijmy tę rozwagę i ostrożność: zachowaniem <span class="code">TRYBU-A</span>
</div>

<div class="paragraphDiv">
    <h2>TRYB-A kontra TRYB-B</h2>
</div>

<div class="paragraphDiv">
    <span class="code">TRYB-A</span> jest o wiele wolniejszy niż <span class="code">TRYB-B</span>. Czas pętli jest niemożliwie długi, zakres funkcjonalności, którą udaje Ci się stworzyć w ciągu każdej pętli jest śmiesznie mały. Dla przykładu, podczas mojej pierwszej pętli w tym procesie napisałem i zdebbugowałem podprogram, który wczytywał linię tekstu z klawiatury, zakończonej znakiem CR (<a
        href="https://pl.wikipedia.org/wiki/CRLF">
    Carriage Return - Powrót Karetki</a>... Tak, dalekopis miał "karetkę", lub raczej "głowicę drukującą", która mogła "powrócić".)
</div>

<div class="paragraphDiv">
    <span class="code">TRYB-B</span> z kolei jest szybki! Naprawdę, naprawdę szybki. Czas pętli jest bardzo krótki, i możesz zrobić o wiele więcej w każdej pętli. Dla przykładu, zabrało mi tylko kilka pętli, żeby zrobić poprawnie animację przechodzenia papierowej taśmy przez czytnik i dziurkacz. Każda maszynowa instrukcja PDP-8 zabrała mi pętlę lub dwie. Sprawienie, aby przesuwał się papier w
    <a href="https://pl.wikipedia.org/wiki/Dalekopis">TTY</a> zajęło mi dwie lub trzy pętle.
</div>

<div class="paragraphDiv">
    No i, oczywiście, nie używałem listingów. Nie pisałem kodu najpierw na papierze. Mogłem pójść gdziekolwiek gdzie chciałem w programie i wyedytować dowolną linię jaką chciałem w mgnieniu oka. Miałem
    <a href="https://pl.wikipedia.org/wiki/Pod%C5%9Bwietlanie_sk%C5%82adni">podświetlanie składni</a>, automatyczne wcięcia, znajdź i zamień, skrollowanie, zakładki, i dokumentację na Internecie.
</div>

<div class="paragraphDiv">
    <span class="code">Tryb-B</span> jest szybki!
</div>

<div class="paragraphDiv">
    <h2>Konieczność TRYBU-B</h2>
</div>

<div class="paragraphDiv">
    Więc dlaczego jeszcze tak wielu programistów wciąż pracuje w TRYBIE-A? Robią to, wiecie. Wrzucają jedną kupę śmieci do na drugą, i framework na framework, aż ich czas pętli rośnie z sekund do minut i dłużej. Wstrzykują tak wiele zależności, że ich buildy stają się kruche i podatne na błędy. Tworzą tak wiele niewyizolowanych zewnętrznych zależności, że mogliby równie dobrze używać papierowej taśmy. Jak ktokolwiek może robić
    <em>cokolwiek</em>, co może zwiększyć czas trwania jego pętli? Dlaczego nikt nie <em>broni czasu swoich pętli z narażeniem
    życia</em>?
</div>

<div class="paragraphDiv">
    Czy unikanie <span class="code">TRYBU-A</span> nie jest naszą moralną powinnością? Czy nie powinniśmy robić wszystkiego, co tylko możliwe, aby utrzymać nasze cykle rozwoju oprogramowania w
    <span class="code">TRYBIE-B</span>?
</div>

<div class="paragraphDiv">
    Czy chcesz poznać sekret pozostawania w <span class="code">TRYBIE-B</span>? Wiem, co to jest. Powiem Ci.
</div>

<div class="paragraphDiv cite">
    Sekretem pozostawania w <span class="code">TRYBIE-B</span> jest użycie zachowania <span class="code">TRYBU-A</span>
</div>

<div class="paragraphDiv">
    <h2>A NIECH MNIE BIJĄ KULE METODOLOGII STRUKTURALNEJ!</h2>
</div>

<div class="paragraphDiv">
    Właśnie odkryłem kto napisał assembler PAL III na PDP-8. Czapki z głów. Był to <a
        href="http://en.wikipedia.org/wiki/Edward_Yourdon">Ed Yourdon</a>.
</div>

<div class="paragraphDiv">
    Program dla PDP-8, który przyjmuje dwie liczby i pojedynczy operator, i wyświetla wynik.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">           *20
0020  7563  MCR,    -215
0021  0212  KLF,    212
0022  7540  MSPC,   -240
0023  7520  MZERO,  -260
0024  7766  M10,    -12
0025  0276  PROMPT, 276 /&gt;
0026  0215  KCR,    215
0027  7525  MPLUS,  -253
0030  7523  MMINUS, -255
0031  0277  QMARK,  277
0032  0260  KZERO,  260

            /WORKING STORAGE
0033  0000  REM,    0

            /CALL SUBROUTINE IN ARG
0034  0000  CALL,   0
0035  3046          DCA AC
0036  1434          TAD I CALL
0037  3047          DCA CALLEE
0040  1034          TAD CALL
0041  7001          IAC
0042  3447          DCA I CALLEE
0043  2047          ISZ CALLEE
0044  1046          TAD AC
0045  5447          JMP I CALLEE
0046  0000  AC,     0
0047  0000  CALLEE, 0

----------------

            *200
            /CALC A+B OR A-B
            /MAIN LOOP: PROMPT, GET CMD, PRINT RESLT

0200  6046          TLS
0201  7200  IDLE,   CLA
0202  1026          TAD KCR
0203  4034          JMS CALL
0204  0425          PRTCHAR
0205  7200          CLA
0206  1025          TAD PROMPT
0207  4034          JMS CALL
0210  0425          PRTCHAR
0211  4034          JMS CALL
0212  0400          RDBUF
0213  2000          BUF
0214  4034          JMS CALL
0215  0462          SKPSPC
0216  2000          BUF
0217  3222          DCA .+3
0220  4034          JMS CALL
0221  0477          GETNUM
0222  0000          0
0223  3261          DCA A
0224  1622          TAD I .-2
0225  3263          DCA OP
0226  1222          TAD .-4
0227  7001          IAC
0230  3233          DCA .+3
0231  4034          JMS CALL
0232  0477          GETNUM
0233  0000          0
0234  3262          DCA B
0235  1263          TAD OP
0236  1027          TAD MPLUS
0237  7650          SNA CLA
0240  5254          JMP ADD
0241  1263          TAD OP
0242  1030          TAD MMINUS
0243  7650          SNA CLA
0244  5251          JMP SUB
0245  1031          TAD QMARK
0246  4034          JMS CALL
0247  0425          PRTCHAR
0250  5201          JMP IDLE

0251  1262  SUB,    TAD B
0252  7041          CIA
0253  7410          SKP
0254  1262  ADD,    TAD B
0255  1261          TAD A
0256  4034          JMS CALL
0257  0600          PRTNUM
0260  5201          JMP IDLE

0261  0000  A,      0
0262  0000  B,      0
0263  0000  OP,     0

----------------

            *400
            /READ A BUFFER UP TO A CR
0400  0000  RDBUF,  0
0401  7200          CLA
0402  1600          TAD I RDBUF
0403  2200          ISZ RDBUF
0404  3215          DCA BUFPTR
0405  4216  RDNXT,  JMS RDCHAR
0406  3615          DCA I BUFPTR
0407  1615          TAD I BUFPTR
0410  1020          TAD MCR
0411  7450          SNA
0412  5600          JMP I RDBUF
0413  2215          ISZ BUFPTR
0414  5205          JMP RDNXT
0415  0000  BUFPTR, 0

            /READ ONE CHAR
0416  0000  RDCHAR, 0
0417  7200          CLA
0420  6031          KSF
0421  5220          JMP .-1
0422  6036          KRB
0423  4225          JMS PRTCHAR
0424  5616          JMP     I RDCHAR

            /PRINT ONE CHAR
0425  0000  PRTCHAR,0
0426  6041          TSF
0427  5226          JMP .-1
0430  6046          TLS
0431  3245          DCA CH
0432  1245          TAD CH
0433  1020          TAD MCR
0434  7440          SZA
0435  5242          JMP RETCHR
0436  1021          TAD KLF
0437  6041          TSF
0440  5237          JMP .-1
0441  6046          TLS
0442  7200  RETCHR, CLA
0443  1245          TAD CH
0444  5625          JMP I PRTCHAR
0445  0000  CH,     0


            /PRT A BUFFER
0446  0000  PRTBUF, 0
0447  7200          CLA
0450  1646          TAD I PRTBUF
0451  2246          ISZ PRTBUF
0452  3215          DCA BUFPTR
0453  1615  PRTNXT, TAD I BUFPTR
0454  4225          JMS PRTCHAR
0455  2215          ISZ BUFPTR
0456  1020          TAD MCR
0457  7640          SZA CLA
0460  5253          JMP PRTNXT
0461  5646          JMP I PRTBUF

----------------

            /SKIP SPACES AC= FIRST NON-SPACE
0462  0000  SKPSPC, 0
0463  7200          CLA
0464  1662          TAD I SKPSPC
0465  2262          ISZ SKPSPC
0466  3215          DCA BUFPTR

0467  1615  NXTCHR, TAD I BUFPTR
0470  2215          ISZ BUFPTR
0471  1022          TAD MSPC
0472  7650          SNA CLA
0473  5267          JMP NXTCHR
0474  7240          CLA CMA
0475  1215          TAD BUFPTR
0476  5662          JMP I SKPSPC

            /GET DECIMAL NUMBER
0477  0000  GETNUM, 0
0500  7200          CLA
0501  3335          DCA NUMBER
0502  1677          TAD I GETNUM
0503  3215          DCA BUFPTR

0504  1615  NXTDIG, TAD I BUFPTR
0505  1023          TAD MZERO
0506  3334          DCA DIGIT
0507  1334          TAD DIGIT
0510  7710          SPA CLA
0511  5327          JMP NONUM
0512  1024          TAD M10
0513  1334          TAD DIGIT
0514  7700          SMA CLA
0515  5327          JMP NONUM
0516  1335          TAD NUMBER
0517  7100          CLL
0520  7006          RTL
0521  1335          TAD NUMBER
0522  7004          RAL
0523  1334          TAD DIGIT
0524  3335          DCA NUMBER
0525  2215          ISZ BUFPTR
0526  5304          JMP NXTDIG
0527  1215  NONUM,  TAD BUFPTR
0530  3677          DCA I GETNUM
0531  2277          ISZ GETNUM
0532  1335          TAD NUMBER
0533  5677          JMP I GETNUM
0534  0000  DIGIT,  0
0535  0000  NUMBER, 0

----------------

            /DIVIDE AC BY ARG
            /Q IN AC, R IN REM
0536  0000  DIV,    0
0537  3033          DCA REM
0540  1736          TAD I DIV
0541  2336          ISZ DIV
0542  7041          CIA
0543  3361          DCA MDVSOR
0544  3362          DCA QUOTNT
0545  1033          TAD REM
0546  1361  DIVLUP, TAD MDVSOR
0547  7510          SPA
0550  5353          JMP DIVDUN
0551  2362          ISZ QUOTNT
0552  5346          JMP DIVLUP
0553  7041  DIVDUN, CIA
0554  1361          TAD MDVSOR
0555  7041          CIA
0556  3033          DCA REM
0557  1362          TAD QUOTNT
0560  5736          JMP I DIV
0561  0000  MDVSOR, 0
0562  0000  QUOTNT, 0

----------------

                    *600
                    /PRINT NUMBER IN DECIMAL
                    DECIMAL
0600  0000  PRTNUM, 0
0601  4034          JMS CALL
0602  0536          DIV
0603  1750          1000
0604  4225          JMS PRTDIG
0605  7200          CLA
0606  1033          TAD REM
0607  4034          JMS CALL
0610  0536          DIV
0611  0144          100
0612  4225          JMS PRTDIG
0613  7200          CLA
0614  1033          TAD REM
0615  4034          JMS CALL
0616  0536          DIV
0617  0012          10
0620  4225          JMS PRTDIG
0621  7200          CLA
0622  1033          TAD REM
0623  4225          JMS PRTDIG
0624  5600          JMP I PRTNUM

            /PRINT A DIGIT IN AC
                    OCTAL
0625  0000  PRTDIG, 0
0626  1032          TAD KZERO
0627  4034          JMS CALL
0630  0425          PRTCHAR
0631  5625          JMP I PRTDIG

----------------

            *2000
2000  0000  BUF,0
</pre></div>

</div>

<!---------- -->
<div class="paragraphDiv">
    
</div>

<div class="smallGreyText">
    <hr/>
    <div>
        Powyższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina z dnia 21 lutego 2015
        ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html">https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>


</body>

</html>