<!DOCTYPE html>

<html>
<head>

    <meta charset="UTF-8">
    <style scoped="scoped" type="text/css">
        .paragraphDiv {
            margin: 0 1em 0.5em 1em;
        }

        img {
            margin: 10px;
        }

        .cite {
            padding: 1em;
            margin: 1em;
            border-left: solid;
            border-color: #eef2f5;
        }

        .smallGreyText {
            text-align: center;
            color: #999999;
            font-size: 0.6em;
            margin: 1em 0.1em 1em 0.1em;
        }

        .code {
            font-family: monospace;
        }

    </style>

</head>
<body>

<br/>

<div class="paragraphDiv">
    Jeżeli śledzisz moje konta na <a href="https://twitter.com/unclebobmartin">twitterze</a>, <a href="https://www.facebook.com/robertcecilmartin">facebooku</a> czy
    <a href="https://github.com/unclebob?tab=repositories">githubie</a>, mogłeś zauważyć, że piszę <a
        href="https://github.com/unclebob/PDP8EmulatorIpad">emulator PDP-8 na iPada</a>.
</div>

<div class="paragraphDiv">
    Oto screenshot:

    TODO: pdp8Shot.jpg
</div>

<div class="smallGreyText">
    <hr/>
    <div>
        Poniższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina z dnia 21 lutego 2015
        ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html">https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>
<br/>

<div class="paragraphDiv">
    Moim celem napisania tego emulatora (poza zwykłą nostalgią) jest wykorzystanie go jako narzędzia szkoleniowego dla nowych programistów. Myślę, że każdy świeżo upieczony programista powinien spędzić tydzień lub dwa programując na jednej z tych starych maszyn. Wydaje mi się, że nie ma lepszego sposobu, aby zrozumieć, czym komputer tak naprawdę jest, jak tylko móc dotknąć prawdziwego komputera i móc zaprogramować go na poziomie bitów, w języku maszynowym. Jak tylko to zrobisz, cała magia zniknie i zostanie zastąpiona przez twardą, brutalną rzeczywistość. I, coś Ci powiem, programowanie PDP-8 jest
    <em>twardą, brutalną, rzeczywistością</em>. A niech mnie, jak cholera!
</div>

<div class="paragraphDiv">
    Chciałem być wierny maszynie i jej środowisku. Panel Przedni jest przyzwoitą abstrakcyjną reprezentacją oryginalnego PDP-8, i światełka zapalają się odpowiednio, i z prawidłowymi danymi. (chociaż nie mogłem się oprzeć i zrobiłem światełka wrażliwe na dotyk, tak jak w ECP-18)

    TODO : pdp8i_frontpanel.jpg
</div>

<div class="paragraphDiv">
    Papierowe taśmy w czytniku i dziurkacz poruszają się z odpowiednimi prędkościami i dziurki reprezentują prawdziwe dane. Wydają one także odpowiednie rodzaje dźwięków. Teletekst drukuje z odpowiednią prędkościa (chociaż możesz go przyspieszyć, jeśli chcesz (będziesz chciał)) i zachowuje się mniej więcej jak
    <a href="https://en.wikipedia.org/wiki/Teletype_Model_33">ASR-33</a>, wydając odpowiednie dźwięki, i reagując odpowiednio na znaki powrótu karetki i wysuwu wiersza, itd. (Tak, możesz naddrukować!)
</div>

<div class="paragraphDiv">
    Znalazłem jakieś binarne obrazy starego PDP-8 <a href="http://dustyoldcomputers.com/pdp-common/reference/papertapes/dec-08.html">tutaj</a>, i udało mi się  wrzucić je do mojego emulatora,
    <a href="https://en.wikipedia.org/wiki/Mung_(computer_term)">miażdżąc</a> ich format przy użyciu małego programu w C, i wrzucając je na iPada używając Dropboxa. Wynik tych działań był zarówno satysfakcjonujący jak i łapiący za serce. Starożytny kod działa!
</div>

<div class="paragraphDiv">
    Usiadłem przy klawiaturze bluetooth mojego 600 dolarowego, ćwierćkilogramowego, obudowanego w fajny pokrowiec iPada, otoczony podręcznikami programowania, i poznaczonymi listingami programu nad którym pracowałem. Uświadomiłem sobie wtedy, że pracuję nad kodem napisanym pół wieku temu, stworzonym przez mężczyzn i kobiety (prawdopodobnie w wiekszości przez kobiety w tamtych czasach), którzy zakasywali rękawy, aby sprawić, żeby ich głupiutka maszyna działała. Maszyna, która ważyła 225 kg, była rozmiaru lodówki i kosztowała 20'000$ w roku 1967.
</div>

<div class="paragraphDiv">
    Czy ktokolwiek z tych ludzi mógłby kiedykolwiek przypuszczać, że ich kod będzie odpalany na podręcznym tablecie i będzie używany do szkolenia programistów w dwudziestym pierwszym wieku? Niektórzy - wielu - może jeszcze żyć. Ciekawe co pomyśleliby, gdyby wiedzieli.

    TODO pdp8InKitchen.jpg
</div>

<div class="paragraphDiv">
    Mój emulator napisany jest w <a href="https://www.lua.org/about.html">Lua</a>, przy użyciu frameworku <a href="http://twolivesleft.com/Codea/">Codea</a> dla iPada. Jest to niezwykle wygodny język dla developmentu na iPada. Lua jest (wystarczająco) szybki, i Codea ma wspaniałe kontrolki graficzne, i prosty, acz nadal bardzo skuteczny framework do tworzenia wysoce interaktywnych programów pełnych animacji.
</div>

<div class="paragraphDiv">
    To załatwiło animację (i generowanie dźwięku) na przednim panelu, dalekopis, i czytnik/dziurkacz papieru za jednym zamachem.
</div>

<div class="paragraphDiv">
    Emulowanie bebechów PDP-8 staje się niezłym wyzwaniem odkąd Lua ma tylko jeden typ numeryczny: zmiennoprzecinkowy. Tworzenie 12 bitowej logiki przy użyciu li tylko matematyki zmiennoprzecinkowej, jest, hmmm, <em>interesujące</em>. Z drugiej strony, miałem niezłą frajdę z oglądania FOCAL(FORmula CALculator: języka podobnego do Basica) odpalonego na moim PDP-8, dokonującego obliczeń zmiennoprzecinkowych, używając operacji logicznych, które to z kolei wymyśliłem przy użyciu matematyki zmiennoprzecinkowej LUA.
    <span class="code">&ltuśmiech&gt</span> Powinieneś był zobaczyć, jak te światełka mrugały!
</div>

<div class="paragraphDiv">
    Prędkość uruchomieniowa to około 4000 instrukcji na sekundę. Mimo, że to tylko 1/7 prędkości PDP-8/S, było to całkiem imponujące jak na iPada wykonywującego język "interpretowanego byte-codu" taki jak Lua, emulującego 12-bitową logikę przy użyciu obliczeń zmiennoprzecionkowych! Nie spodziewałem się takiej szybkości. W zasadzie odpala cały ten stary software firmy
    <a href="https://pl.wikipedia.org/wiki/Digital_Equipment_Corporation">DEC</a> z sensowną prędkością. Nawet <span
        class="code">FOCAL</span> działa wystarczająco szybko do obliczania pierwiastków kwadratowych w coś koło pół sekundy.
</div>

<div class="paragraphDiv">
    I, znowu, te mruganie światełek podczas kompilacji jest bardzo przyjemne. Tylko popatrz, a od razu odkryjesz, czym były inspirowane filmy science-fiction z lat 50-tych XX. wieku.
</div>

<div class="paragraphDiv">
<h2>TRYB-B</h2>
</div>

<div class="paragraphDiv">
    Sprawienie, aby kompilator działał było naprawdę bardzo łatwe. Prawdopodobnie spędziłem nad tym w całości 30 godzin; i to włącznie z uczeniem się Codea i Lua.
</div>

<div class="paragraphDiv">
    Proces developmentu pędził jak szalony. Edytor Lua w Codea dla iPada jest potężyny i intuicyjny (chociaż nie ma refaktoringów
    <span class="code">&ltchlip&gt</span>). Pętla edycji/stestowania trwała, może, 10 sekund. Mogłem dodać linie, czy dwie, odpalić appkę, zobaczyć efekt, wskoczyć z powrotem do edytora ot tak. To była przyjemne udogodnienie i miałem przy tym niezłą zabawę.
</div>

<div class="paragraphDiv">
    Oczywiście napisałem testy do trudniejszych kawałków. Napisałem mały framework testowy, tylko do tego celu, i dodałem przycisk
    <span class="code">TEST</span> na panelu przednim emulatora, aby ułatwić sobie odpalanie tych testów. Kod emulacji sam w sobie byłby prawie niemożliwy do napisania, gdybym nie miał tych testów. I, oczywiście, korzystałem z dyscypliny TDD przy pisaniu tego kodu. Koniec końców powstało ponad 100 testów dla najróżniejszych instrukcji i zachowań komputera PDP-8.
</div>

<div class="paragraphDiv">
    Dla GUI, z drugiej strony (i było tam mnóstwo kodu GUI), testy były niepotrzebne(<span class="code">&ltoch&gt</span>). Moje oczy były testami. Wiedziałem, co chcę zobaczyć, więc rozkręciłem 10-sekundową pętlę edytuj/stestuj. Pisanie testów w stylu TDD byłoby okropnie trudne, i stałyby się całkowitą stratą czasu.
</div>

<div class="paragraphDiv">
    Z drugiej strony, to był nadal <em>rytm</em> TDD. Wiedziałem, co chcę zobaczyć na ekranie. To był mój test. Po prostu zmodyfikowałem kod zanim test został spełniony. A więc nawet jeśli nie pisałem testów, czułem się tak, jakbym pisał -
    <em>czułem się, jak podczas TDD</em>.
</div>

<div class="paragraphDiv">
    Oczywiście to prawda, że nie miałem zautomatyzowanych testów regresji dla mojego GUI. Z drugiej strony upewnienie się czy wszystko działa było absurdalnie proste. W ten sposób brak zautomatyzowanych testów GUI nie wpłynął na czas trwania mojej pętli.
</div>

<div class="paragraphDiv">
    Oczywiście, bez narzędzi do refaktoringu kod zrobił się trochę zabałaganiony. Zrefaktorowałem to, czego nie mogłem znieść; ale rozmiar zabałagacenia jest większy niżbym chciał. Uda mi się sprzątnąć ten kod; ale dużo wolniej pracuje się bez dobrych narzędzi do refaktoringu.
</div>

<div class="paragraphDiv">
    Tym nie mnie, na potrzeby tego artykułu, nazwijmy ten styl programowania: <span class="code">TRYB-B</span>. <span
        class="code">TRYB-B</span> jest stylem, który pozwala Ci jednocześnie edytować coś na ekranie i widzieć na tym ekranie skutki, lub test, który przechodzi, w ciągu kilku sekund. To development o prędkości światła, który nie wymaga listingów, ołówków, czasu kompilacji, czasu poświęconego na ustawienie, lub żadnego innego utrudnienia. Czas pomiędzy edytowaniem kodu, a oglądaniem go działającego jest dużo mniejszy niż jedna minuta.
</div>

<div class="paragraphDiv">
<h2>TRYB-A</h2>
</div>

<div class="paragraphDiv">
    Mając działający Emulator PDP-8, i mając te wszystkie stare narzędzia takie, jak edytor taśmy papierowej, i działający assembler Pal-3, zabrałem się za pisanie prostego programu. Ten program pozwoliłby użytkownikoi wpisać prostą formułę na klawiaturze, i wtedy wyświetliłby wynik. Dla przykładu, jeśli użytkownik wpisałby:
    <span class="code">25+32</span>, komputer wyświetliłby
    <span class="code">57</span>.
</div>

<div class="paragraphDiv">
    Na PDP-8 to nie jest trywialny program. Zamieściłem go poniżej dla tych z Was, którzy chcieliby zobaczyć, jak biedni programiści PDP-8 musieli to pisać.
</div>


<div class="paragraphDiv">
    Proces był taki sam jak proces, którego używałem w późnych latach 70-tych XX. wieku kiedy pracowałem nad assemblerowymi programami w na Teradyne M365 (18-bitowy kuzyn PDP-8). Mieliśmy taśmę magnetyczną, zamiast taśmy papierowej; i komputer był troszkę potężniejszy obliczeniowo niż PDP-8. Ale proces pozostawał taki sam. A leciało to tak:
</div>

<div class="paragraphDiv">
    Załóżmy, że jesteś w środku pisania tego programu poniżej. Już trochę napisałeś, i chcesz coś jeszcze dodać. Pamiętaj, ten komputer posiada słowa o długości tylko
    <span class="code">4K</span>. Nie może przechowywać wiele w swojej pamięci. Pamiętaj o tym, że jedynym magazynem pamięci masowej, którym dysponujesz jest papierowa taśma. Także twój kod źródłowy jest na tym samym długim pasku tej samej papierowej taśmy.
</div>

<!---------- -->

<div class="paragraphDiv">
    <ol>
        <li>
            Zapisujesz zmiany jakie chcesz wprowadzić do programu na aktualnym listingu.
        </li>
    </ol>
</div>


<div class="smallGreyText">
    <hr/>
    <div>
        Powyższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina z dnia 21 lutego 2015
        ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html">https://blog.cleancoder.com/uncle-bob/2015/02/21/ModeBImperative.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>


</body>

</html>