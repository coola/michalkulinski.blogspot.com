<!DOCTYPE html>

<html>
<head>

    <meta charset="UTF-8">
    <style scoped="scoped" type="text/css">
        .paragraphDiv {
            margin: 0 1em 0.5em 1em;
        }

        img {
            margin: 10px;
        }

        .cite {
            padding: 1em;
            margin: 1em;
            border-left: solid;
            border-color: #eef2f5;
        }

        .smallGreyText {
            text-align: center;
            color: #999999;
            font-size: 0.6em;
            margin: 1em 0.1em 1em 0.1em;
        }

        .code {
            font-family: monospace;
        }

    </style>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            showMathMenu: false,
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
    </script>


    <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>


</head>
<body>

<br/>

<div class="paragraphDiv">
    <h4>Dlaczego to programowanie nazywa się funkcyjne?</h4>
</div>

<div class="paragraphDiv">
    W <a href="https://michalkulinski.blogspot.com/2019/02/podstawy-programowania-funkcyjnego-epizod-1.html">poprzednim odcinku</a> opowiedziałem ci o co chodzi z tym całym zgiełkiem wokół programowania funcyjnego. Pamietasz: Przejrzystość Referencyjną i pociąg towarowy z wieloma rdzeniami? Skoro jest tu, i czytasz odcinek 2., zakładam, że moje argumenty przekonały Cię i chcesz dowiedzieć się czegoś więcej.
</div>


<div class="smallGreyText">
    <hr/>
    <div>
        Poniższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina z dnia 02 stycznia 2013
        ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2013/01/02/FPBE2-Whys-it-called-functional.html">https://blog.cleancoder.com/uncle-bob/2013/01/02/FPBE2-Whys-it-called-functional.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>
<br/>

<div class="paragraphDiv">
    A więc następnym pytaniem, które czeka na odpowiedź jest: Dlaczego to nazywa się "Funkcyjnym" programowaniem? Prostą odpowiedzią na to pytanie jest, że Programowanie Funkcyjne to programowanie przy użyciu funkcji (ehhh). Spośród wszystkich odpowiedzi, ta jest całkiem słaba. No, jest akurat precyzyjna, i brzmi całkiem nieźle; ale tak naprawdę nie odpowiada na nasze pytanie. W końcu, programy napisane w Javie są programami z funkcjami.
</div>

<div class="paragraphDiv">
    A więc dlaczego słowo "funkcyjne"?
</div>

<div class="paragraphDiv">
    Wkurzę pewnie w tej chwili wszystkich matematycznych perfekcjonistów; ponieważ zamierzam użyć analogii z <a
        href="https://pl.wikipedia.org/wiki/Rachunek_r%C3%B3%C5%BCniczkowy_i_ca%C5%82kowy">rachunkiem różniczkowym</a>. Nie będę się tym przejmował za bardzo, bo po prostu ukradłem ten pomysł z Wikipedii.
</div>

<div class="paragraphDiv">
    Czy wiesz, co znaczy $\frac{dy}{dx}$? W szczególności, w wyrażeniu $\frac{dy}{dx}$ czym jest $y$? Oczywiście $y$ jest funkcją. $\frac{dy}{dx}$ jest
    <a href="https://pl.wikipedia.org/wiki/Pochodna_funkcji">pochodną</a> tej funkcji. Czyli $\frac{dy}{dx}$ przyjmuje funkcję jako swój argument wejściowy i zwraca pochodną tej funkcji jako wynik. Mam rację?
</div>

<div class="paragraphDiv">
    Rozważ $\frac{d(x^2)}{dx}$: równa się $2x$. Zauważ, że $2x$ jest funkcją. Więc argument wejściowy i wyjściowa wartość są funkcjami.
</div>

<div class="paragraphDiv">
    Czekaj. Jak nazwiesz coś, co przyjmuje argumenty i zwraca wartość? Nazwiesz to funkcją. A więc $\frac{dy}{dx}$ jest funkcją, która przyjmuje funkcję i zwraca funkcję.
</div>

<div class="paragraphDiv">
    Co by było gdybyśmy mieli taki język programowania komputerów? Co by było gdybyśmy mogli pisać funkcje, które przyjmują funkcje jako argumenty, operować na nich, bez rozwiązywania ich, i potem zwracać nowe funkcje jak wynik? Jak byś taki język mógł nazwać? Jakie inne słowo mogłoby być lepsze niż: funkcyjny?
</div>

<div class="paragraphDiv">
    I już widzę tych purystów języków funkcjonalnych wściekłych na mnie, za to, że to kompletnie nieodpowiedni sposób definicji języka funkcyjnego. Ale to jest jeden krok do przodu &ndash; i to bardzo ważny krok.
</div>

<div class="paragraphDiv">
    A więc, co to znaczy przesłąć funkcję jako argument do innej funkcji? Spójrzy jeszcze raz na program kwadraty liczb całkowitych. Pamiętasz, to było po prostu:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(take 25 (squares-of (integers)))
</pre></div>

</div>

<div class="paragraphDiv">
    Zróbmy z tego funkcję, dodając nazwę i definicję argumentu:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="font-weight: bold">defn </span>squint [n]
  (take n (squares-of (integers))))
</pre></div>

</div>

<div class="paragraphDiv">
    Jestem pewny, że ogarniasz składnię sam. To nic trudnego.
</div>

<div class="paragraphDiv">
    Mając definicję <span class="code">squint</span>, możemy wyświetlić 25 kwadratów liczb całkowitych przy użyciu:
</div>


<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(println (squint 25))
</pre></div>

</div>

<div class="paragraphDiv">
Jak dotąd, to nic innego, jak tylko proste wywołania funkcji i definicje. Ale czym jest ta funkcja <span class="code">squares-of</span>. Jak jest zdefiniowana?
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="font-weight: bold">defn </span>square [n] (* n n))

(<span style="font-weight: bold">defn </span>squares-of [list]
  (map square list))
</pre></div>

</div>

<div class="paragraphDiv">
    Teraz zaczyna się robić trochę bardziej interesująco! Nie jest niespodzianką, że funkcja <span class="code">square</span> po prostu mnoży argument przez jego samego. To definicja <span class="code">squares-of</span> jest interesująca, ponieważ przesyła funkcję <span class="code">square</span> jako argument do funkcji o nazwie <span class="code">map</span>.
</div>

<div class="paragraphDiv">
    Funkcja <span class="code">map</span> jest jedną z podstaw programowania funkcyjnego. Pobiera dwa argumenty: funkcję $f$ i listę $l$; i zwraca nową listę wywołując funkcję $f$ na każdym elemencie listy $l$.
</div>

<div class="paragraphDiv">
    Przesyłanie funkcji jako argument to nie jest coś, co programiści Javy robią często. Z drugiej strony nie jest to zupełnie obcy pomysł. Każdy programista Javy, który uczył się
    <a href="https://pl.wikipedia.org/wiki/Polecenie_(wzorzec_projektowy)">Wzorca Polecenie</a>, lub używał Listenerów w
    <a href="https://en.wikipedia.org/wiki/Swing_(Java)">
        Swingu</a>, zrozumie, co tu się dzieje.
</div>

<div class="paragraphDiv">
    Co więcej, obecnie coraz więcej języków programowania zaczęło wykorzystować pomysł funkcji przekazywanych jako argumenty. Ta funkcjonalność jest czasem nazywana "bloki" lub "lambdy". Jest bardzo częstym elementem języka Ruby; stało się ostatnio ważną częścią C#. Chodzą słuchy, że ta funkcjonalność zostanie dodana w Javie niedługo.<a id="1a" href="#1">[1]</a>
</div>

<div class="paragraphDiv">
    Więc może nie będziemy musieli uczyć się nowego języka. Może nasze stare języki będą stawały się coraz bardziej i bardziej funkcyjne i będziemy mogli używać tych funkcyjnych funkcjonalności, jak tylko staną się on coraz bardziej dostępne.
</div>

<div class="paragraphDiv">
    Ta droga prowadzi do szaleństwa, płaczu i zgrzytania zębami! Język z funkcjonalnościami funkcyjnymi nie jest językiem funkcyjnym; i program napisany z kilkoma lambdami tu i tam, nie jest funkcyjnym programem.
</div>

<div class="paragraphDiv">
    Żeby przekonać się dlaczego to prawda, musimy spojrzeć na funkcję <span class="code">integers</span>.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="font-weight: bold">defn </span>integers []
  (integers-starting-at 1))
</pre></div>

</div>

<div class="paragraphDiv">
    OK, to nie jest za trudne. Funkcja <span class="code">integers-starting-at</span> po prostu przyjmuje liczbę całkowitą jako argument i zwraca listę wszystkich liczb całkowitych zaczynając od tego, co jest w argumencie.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="font-weight: bold">defn </span>integers-starting-at [n]
  (cons n (lazy-seq (integers-starting-at (inc n)))))
</pre></div>

</div>


<div class="paragraphDiv">
    To wymaga słówka wyjaśnienia. Ale nie bój się, to jest właściwie całkiem proste.
</div>

<div class="paragraphDiv">
    Na początku jest funkcja <span class="code">cons</span>; która jest skrótem dla "zbuduj listę" (construct list). Funkcja <span class="code">cons</span> przyjmuje dwa argumenty, element, i listę. Zwraca nową listę jako starą listę z dołożonym z przodu elementem. Czyli <span class="code">(cons 2 [3 4])</span> zwraca
    <span class="code">[2 3 4]</span>.
</div>


<div class="paragraphDiv">
    Teraz z kolei wszyscy ludzie od Clojure są wkurzeni na mnie, bo to nie jest tak do końca. Z drugiej strony różnica jest czymś, czym nie musimy się teraz przejmować. Na tą chwilę zapamiętaj tylko to: <span class="code">cons</span> tworzy listę poprzez dołożenie jego pierwszego elementu do drugiego; który to drugi musi być listą.
</div>

<div class="paragraphDiv">
    Teraz możesz sobie pomyśleć, że <span class="code">cons</span> po prostu przyczepia ten element z przodu listy; ale to nie jest tak. W rzeczywistości, to nie jest nawet bliskie prawdy. Widzisz, <span class="code">cons</span> w żaden sposób nie zmienia listy z drugiego argumentu. Zamiast tego zwraca całkiem nową listę złożoną z zawartości listy z drugiego argumentu i elementu dodanego na początku.
</div>

<div class="paragraphDiv">
    O kurcza, teraz to już ludzie od Clojure są na mnie naprawdę źli; ponieważ to znowu nie do końca prawda. I pewnie masz mnie za wariata, bo co za głupek kopiowałby całą zawartość jednej listy do drugiej listy tylko po to żeby wrzucić jeden element na początek?
</div>

<div class="paragraphDiv">
    OK, więc, tak <span class="code">cons</span> w zasadzie <em>rzeczywiście</em> wkłada element na początek listy, i nie, nie kopiuje starej listy do nowej listy. Zdrugiej strony, robi to w taki sposób, że możesz udawać, że listy wejściowa i wyjściowa są zupełnie inne. Praktycznie rzecz biorąc wyjście <span class="code">cons</span> jest całkowicie nową listą - nawet, jeśli tak nie jest.
</div>


<div class="paragraphDiv">
    Zbity z tropu? Nie martw się, w rzeczywistości to nie jest takie trudne do zrozumienia. Rozważ listę <span class="code">[1 2 3]</span>. Jeżeli zaimplementujemy ją jako
    <a href="https://pl.wikipedia.org/wiki/Lista">listę jednokierunkową</a>, będzie wyglądała tak: <span class="code">1->2->3</span>. Teraz odpalmy <span class="code">cons</span> z 0 na początku. To daje nam
    <span class="code">0->1->2->3</span>. Zauważ jednak, że stara lista nadal istnieje w nowej liście. To jest tajemnica! Stara lista pozostaje niezmienionaw nowej liście. Więc możemy stworzyć pozory, że <span class="code">cons</span> zwróci całkiem nową listę, pozostawiając stara listę niezmienioną.
</div>

<div class="paragraphDiv">
    To wskazuje na to, co wszystkie prawdziwe języki funkcyjne robią. One pozwalają Ci tworzyć coś, co wydaje Ci się być całkowicie nowymi strukturami danych, podczas gdy one zachowują stare struktury danych nietknięte; i robią to bez kopiowania. W kręgach funkcyjnych to jest znane jako trwałość; i struktury danych, które zachowują się w ten sposób są znane jako
    <a href="https://pl.wikipedia.org/wiki/Trwa%C5%82a_struktura_danych">trwałe struktury danych</a>. Takie struktury danych zarządzają cały czas swoją historią. Nic nigdy nie zostaje wyedytowane lub skasowane w ich wnętrzu. Jednak mają one wiele różnych "punktów-wejścia", każdy z nich zapewnia inny widok na dane. Pomyśl o tym jak o systemie zarządzania kodem źródłowym. Chociaż kasujesz i edytujesz linie kodu; nic nigdy nie kasuje się ani nie edytuje w repozytorium kodu źródłowego. Cała historia jest zachowana. Po prostu masz rózne punkty wejścia do kodu źródłowego, które pozwalają Ci widzieć różne migawki z przeszłości.
</div>


<div class="paragraphDiv">
    A więc wróćmy do naszego programu. Spójrzmy na <span class="code">integers-starting-at</span>
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="font-weight: bold">defn </span>integers-starting-at [n]
  (cons n (lazy-seq (integers-starting-at (inc n)))))
</pre></div>

</div>

<div class="paragraphDiv">
    Co funkcja <span class="code">cons</span> dodaje z przodu i do przodu czego to jest dodawane? Podczas pierwszego przejścia
    <span class="code">n</span> będzie <span class="code">1</span>, więc <span class="code">cons</span> zwróci listę, która rozpoczyna się od <span class="code">1</span>. To ma ogromny sens, ponieważ naszym celem jest wyświetlenie kwadratu z <span class="code">1</span>.
</div>

<div class="paragraphDiv">
    OK, ale co jest to coś, do którego <span class="code">cons</span> dokłada <span class="code">1</span>? To jasne, że <span class="code">1</span> jest dodawana na początku listy zwracanej przez funkcję <span class="code">lazy-seq</span>.
</div>

<div class="paragraphDiv">
    Tutaj zaczyna się magia. Widzisz, <span class="code">lazy-seq</span> jest funkcją, która zwraca tzw. leniwą sekwencję. Leniwa sekwencja to zwykła lista - ale z niespodzianką. Zamiast listy jednokierunkowej z wartościami takimi, jak <span class="code">1->2->3</span>, leniwa sekwencja jest wartością połączoną z funkcją: <span class="code">1->f</span>. Ta funkcja, kiedy jest wywołana, zwraca następną wartość połączoną z inną funkcją: <span class="code">2->f</span>. I z jaką funkcją te wartości są połączone? Popatrz dobrze! To argument funkcji <span class="code">lazy-seq</span>.
</div>

<div class="paragraphDiv">
    Tym argumentem funkcji <span class="code">lazy-seq</span> jest rekurencyjne wywołanie funkcji <span class="code">integers-starting-at</span> z argumentem wartości funkcji <span class="code">(inc n)</span>. Funkcja <span class="code">inc</span> po prostu zwraca jej argument powiększony o <span class="code">1</span>.
</div>

<div class="paragraphDiv">
    A więc czym jest leniwa sekwencja? Leniwa sekwencja jest listą, której elementy są obliczane tylko wtedy, kiedy są potrzebne, i nie wcześniej. Za każdym razem, kiedy prosisz leniwą sekwencję o następny element w liście, ona po prostu wywołuje funkcję, która jest powiązana z aktualnym elementem.
</div>

<div class="paragraphDiv">
    Stąd, leniwa sekwencja nie ma rozmiaru. Możesz wciąż i wciąż pytać o więcej elementów w nieskończoność; i wciąż te elementy nie zostaną obliczone dopóki to nie będzie potrzebne.
</div>

<div class="paragraphDiv">
    Funkcja <span class="code">map</span> też zwraca leniwą sekwencję. Tu jest przykład implementacji:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="font-weight: bold">defn </span>map [f l]
  (<span style="font-weight: bold">if </span>(empty? l)
    []
    (cons (f (first l)) (lazy-seq (map f (rest l))))))
</pre></div>

</div>

<div class="paragraphDiv">
    Funkcja <span class="code">first</span> po prostu zwraca pierwszy element listy będącej jej argumentem. Funkcja <span class="code">rest</span> po prostu zwraca listę z argumentu minus jej pierwszy element; czyli resztę listy. Więc <span class="code">map</span> jest po prostu rekurencyjną funkcją, która odpala funkcję <span class="code">f</span> na każdym elemencie listy <span class="code">l</span>, tworząc nową leniwą sekwencję wyników.
</div>

<div class="paragraphDiv">
    Została nam jeszcze jedna rzecz, zanim złożymy wszystko razem: funkcja <span class="code">take</span>. Po tym wszystkim, co do tej pory razem prześliśmy, ta będzie naprawdę bardzo prosta.
</div>


<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="font-weight: bold">defn </span>take [n l]
  (<span style="font-weight: bold">if </span>(zero? n)
    []
    (cons (first l) (take (dec n) (rest l)))))
</pre></div>

</div>

<div class="paragraphDiv">
    Jak widzisz, funkcja <span class="code">take</span> zwraca listę złożoną z pierwszych <span class="code">n</span> elementów listy <span class="code">l</span>.
</div>

<div class="paragraphDiv">
    A teraz, poćwiczmy trochę Przejrzystość Referencyjną, i rozkodujmy (ręcznie) wartość wywołania:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(squint 2)
</pre></div>

</div>

<div class="paragraphDiv">
    Najpierw podmieńmy <span class="code">squint</span> jej definicją.
</div>

<div class="paragraphDiv">
    Potem podmieńmy <span class="code">take</span> jej definicją. To jest trochę zawiłe, bo musimy użyć rekurencji.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(<span style="font-weight: bold">if </span>(zero? 2)
  []
  (cons (first (squares-of (integers)))
    (<span style="font-weight: bold">if </span>(zero? (dec 2))
      []
      (cons (first (rest (squares-of (integers))))
        (<span style="font-weight: bold">if </span>(zero? (dec (dec 2)))
          []
          ...)))))
</pre></div>

</div>

<div class="paragraphDiv">
    Zatrzymałem się na trzecim wyrażeniu <span class="code">if</span>, ponieważ <span class="code">(dec (dec 2))</span> wynosi zero. W rzeczywistości, znamy wartość logiczną tych <span class="code">if</span>-ów, więc możemy usunąć je wszystkie:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons (first (squares-of (integers)))
  (cons (first (rest (squares-of (integers))))
    []))
</pre></div>
</div>

<div class="paragraphDiv">
    To jasne, że mając tylko dwa wywołania funkcji <span class="code">cons</span>, to zwróci listę z dwoma elementami w środku. Możemy trochę posprzątać zamieniając <span class="code">integers</span> z ich definicjami.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons (first (squares-of (integers-starting-at 1)))
 (cons (first (rest (squares-of (integers-starting-at 1))))
   []))
</pre></div>

</div>

<div class="paragraphDiv">
    Ponieważ wywołanie <span class="code">(squares-of (integers-starting-at 1))</span> występuje dwa razy, obliczmy je raz i zamieńmy wywołania z ich wartościami. Zaczniemy zamianę od <span class="code">squares-of</span>:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(map square (integers-starting-at 1)
</pre></div>

</div>

<div class="paragraphDiv">
    A potem <span class="code">integers-starting-at</span>:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(map square (cons 1 (lazy-seq (integers-starting-at 2)))
</pre></div>

</div>

<div class="paragraphDiv">
    Teraz zamieńmy <span class="code">map</span>. Ponieważ <span class="code">map</span> zaczyna się z <span class="code">(if (empty? l) ...)</span>, i ponieważ <span class="code">(cons 1...)</span> gwarantuje, że lista nie będzie pusta, możemy pominąć wyrażenie <span class="code">if</span> i użyć tylko ciała funkcji.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons (square (first (cons 1 (lazy-seq...))))
  (map square (rest (lazy-seq (integers-starting-at 2)))))
</pre></div>

</div>

<div class="paragraphDiv">
    Ten wywołanie do <span class="code">first</span> może być łatwo zredukowane:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons (square 1)
  (map square (rest (lazy-seq (integers-starting-at 2)))))
</pre></div>

</div>

<div class="paragraphDiv">
    A teraz odrobinę więcej magii. Wywołanie funkcji <span class="code">rest</span> zwraca "resztę" listy poprzez wywołanie funkcji przesłanej do <span class="code">lazy-seq</span>
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons (square 1)
  (map square (integers-starting-at 2)))
</pre></div>

</div>

<div class="paragraphDiv">
    Możemy powtórzyć tę analizę dla <span class="code">(map square (integers-starting-at 2))</span>:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons (square 1)
  (cons (square 2)
    (map square (integers-starting-at 3)))
</pre></div>

</div>

<div class="paragraphDiv">
    I teraz możemy zredukować funkcję <span class="code">squares</span>
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons 1
  (cons 4
    (map square (integers-starting-at 3)))
</pre></div>

</div>

<div class="paragraphDiv">
    Zostawiliśmy naszą poprzednią analizę dla całej funkcji w następującym stanie:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons (first (squares-of (integers-starting-at 1)))
  (cons (first (rest (squares-of (integers-starting-at 1))))
    []))
</pre></div>

</div>

<div class="paragraphDiv">
    Teraz możemy wstrzyknąć naszą wartość dla <span class="code">(squares-of (integers-starting-at 1))</span>.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons
  (first (cons 1
            (cons 4
            (map square (integers-starting-at 3))))
  (cons
    (first (rest (cons 1
                    (cons 4
                    (map square (integers-starting-at 3)))))
    []))
</pre></div>

</div>

<div class="paragraphDiv">
    Pierwsze <span class="code">first</span> jest łatwo zredukować. <span class="code">(first (cons x 1))</span> to po prostu <span class="code">x</span>; więc możemy zignorować drugi argument funkcji <span class="code">cons</span>.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons
  1
  (cons
    (first (rest (cons 1
                       (cons 4
                       (map square (integers-starting-at 3)))))
    []))
</pre></div>

</div>

<div class="paragraphDiv">
    Te <span class="code">(first (rest...))</span> jest także łatwo obliczyć.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">(cons
  1
  (cons 4 []))
</pre></div>

</div>

<div class="paragraphDiv">
    I wynik tego, to oczywiście <span class="code">[1 4]</span>.
</div>

<div class="paragraphDiv">
    Zauważyłeś, co stało się z tym <span class="code">(integers-starting-at 3)</span>? Nigdy nie zostało obliczone. Dlaczego? Ponieważ oryginalna <span class="code">(take 2...)</span> potrzebowała tylko 2 wartości, więc trzecia nigdy nie była potrzebna.
</div>

<div class="paragraphDiv">
    I to prowadzi do ważnego odkrycia. Większość z nas pisze programy, które przepychają dane przez całość programu. Ale <span class="code">(take 25 (squares-of (integers)))</span> jest pętlą, która <em>ciągnie</em> dane z całości programu. To jest gruntowna różnica, i coś, nad czym póżniej zamierzamy spędzić dużo więcej czasu.
</div>

<div class="paragraphDiv">
    Do tego momentu wszyscy ludzie od Clojure, wszyscy ludzie od programowania funkcyjnego, i wszyscy ludzie od matematki są już na mnie porządnie wściekli; ponieważ tak bardzo uprościłem. I to jest prawda; jest ogrom rzeczy, po których tylko się prześlizgąłem i na które machnąłem ręką. Nadal, to co powiedziałem Ci jest istotnie poprawne. Jest to także całkiem niezła prezentacja potęgi traktowania funkcji jak danych, które mogą być przesyłane i zwracane z funkcji.
</div>

<div class="paragraphDiv">
    I to prowadzi nas do sedna tego epizodu. Teraz już możemy odpowiedzieć na pytanie postawione pod tytułem. Nazywamy ten styl programowania funkcyjnym, ponieważ to wszystko jest o traktowaniu funkcji jak cząstek danych, którymi manipuluje się w taki sam sposób jak znakami czy liczbami. Ludzie od programowania funkcyjnego odnoszą się do nich jako do <em><a
        href="https://pl.wikipedia.org/wiki/Typ_pierwszoklasowy"></a>typów pierwszoklasowych</em>. Język funkcyjny jest językiem, który używa funckji jako typów pierwszoklasowych, promuje przejrzystość referencyjną poprzez usuwanie przypisań, i zachowuje historię danych poprzez trwałe struktury danych.
</div>

<div class="paragraphDiv">
    Jak nauczymy się w następnych odcinkach, ta definicja nie jest ani pełna, ani w pełni właściwa; ale na tę chwilę... wystarczy.
</div>

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>


<div class="paragraphDiv">
    <div id="1"><a href="#1a">[1]</a> - Została dodana dopiero 18 marca 2014 roku wraz z 8. wersją Javy. [przyp. tłum.]</div>
</div>




<div class="smallGreyText">
    <hr/>
    <div>
        Powyższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina z dnia 02 stycznia 2013
        ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2013/01/02/FPBE2-Whys-it-called-functional.html">https://blog.cleancoder.com/uncle-bob/2013/01/02/FPBE2-Whys-it-called-functional.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>


</body>

</html>