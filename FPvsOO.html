<style type="text/css" scoped="scoped">
    .paragraphDiv {
        margin-bottom: 2em;
    }
    img {
        margin: 10px;
    }
    .smallGreyText{
        text-align: center;
        color: #999999;
        font-size: 0.6em;
        margin:0 0.1em 0 0.1em;
    }
    .cite {
        padding: 1em;
        margin: 1em;
        border-left: solid;
        border-color: #eef2f5;
    }
    .code{
        font-family: monospace;
    }

</style>

<meta charset="UTF-8">

<h1>OO kontra FP</h1>

<div class="paragraphDiv">
    Przez kilka ostatnich lat programowałem w parach z ludźmi uczącymi się Programowania Funkcyjnego, którzy manifestowali
    swoją niechęć do OO. To zwykle sprowadzało się do stwierdzenia pokroju: "Ooo, to za bardzo przypomina Obiekt".
</div>

<div class="smallGreyText">
    <hr />
    <div>Poniższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina ze strony :</div>
    <br/>
    <div><a href="https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html</a></div>
    <br/>
    <div>Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.</div>
    <hr />
</div>
<br/>

<div class="paragraphDiv">
    Myślę, że to wynika z przekonania, że FP i OO są jakoś wzajemnie rozłączne. Wydaje mi się, że wiele osób myśli, że jeżeli program
    jest funkcyjny w całości, to <i>nie jest</i> już zorientowany obiektowo. Przypuszczam, że ta opinia wynika z naturalnej
    konsekwencji uczenia się czegoś nowego.
</div>

<div class="paragraphDiv">
    Wtedy, kiedy zajmujemy się nową techniką, często mamy tendencję do odrzucania starych technik używanych przez nas wcześniej.
    To jest naturalne, ponieważ wierzymy, że ta nowa technika będzie "lepsza" i stąd ta ta stara technika musi byś "gorsza".
</div>

<div class="paragraphDiv">
    W tym wpisie stawiam tezę, że ponieważ OO i FP mają punkty wspólne, nie mogą być wzajemnie rozłączne. Dobry program funkcyjny może (i powinien)
    być zorientowany obiektowo. I dalej, dobry program zorientowany obiektowo może (i powinien) być funkcyjny. Ale żeby osiągnąć ten cel musimy
    bardzo ostrożnie zdefiniować nasze pojęcia.
</div>

<h3>Co to jest OO?</h3>

<div class="paragraphDiv">
    Zamierzam tutaj przyjąć abrdzo <a href="https://sjp.pwn.pl/sjp/redukcjonizm;2573615.html">redukcjonistyczną</a> postawę.
    Jest wiele poprawnych definicji OO które obejmują bogaty zestaw pomysłów, zasad, technik, wzorców i filozofii. Zamierzam ominąć to wszystko
    i skupić się na podstawach. Powód dla takiego redukcjonizmu jest taki, że te wszystkie bogactwa otaczające OO nie są
    dla niego specyficzne; ale są częścia bogactwa tworzenia oprogramowania w ogólności. Tutaj, skupię się tylko na tej części OO,
    która jest ostateczne i nierozerwalna.
</div>

<div class="paragraphDiv">
    Rozważ te dwa wyrażenia:
</div>

<div class="paragraphDiv cite code">
    <b>1</b>: f(o);
    <br/>
    <b>2</b>: o.f();
</div>

<div class="paragraphDiv">
    Jaka jest różnica?
</div>

<div class="paragraphDiv">
    Jasne jest to, że właściwie nie ma różnicy w znaczeniu. Cała różnica siedzi w składni. Ale jedno wyrażenie wygląda proceduralnie, a drugie wygląda na zorientowane obiektowo. A to z takiego powodu, że wnioskujemy dodatkowe zachowanie z wyrażenia 2., którego nie znajdujemy w wyrażeniu 1. Tym dodatkowym zachowaniem w wyrażeniu jest: polimorfizm.
</div>

<div class="paragraphDiv">
    Kiedy widzimy wyrażenie 1. widzimy funkcję nazwaną <span class="code">f</span> wołaną na obiekcie o nazwie <span class="code">o</span>. Wnioskujemy, że jest tylko jedna taka funkcja o nazwie <span class="code">f</span> i że nie jest jedną z grupy standardowych funkcji otaczających <span class="code">o</span>.
</div>

<div class="paragraphDiv">
    Z drugiej strony, kiedy patrzymy na wyrażenie 2. widzimy obiekt o nazwie <span class="code">o</span>, któremu wysyłana jest wiadomość o nazwie <span class="code">f</span>. Wnioskujemy, że tam mogą być inne rodzaje obiektów, które akceptują wiadomość nazwaną <span class="code">f</span> i z tego powodu nie wiemy która szczególna funkcja <span class="code">f</span> właściwie zostanie wywołana. <i>Zachowanie jest zależne od typu obiektu <span class="code">o</span></i> tzn. <span class="code">f</span> jest polimorficzna.

</div>

<div class="paragraphDiv">
    To spodziewanie sie polimorfizmu jest istotą programowania OO. To jest definicja redukcjonistyczna; i jest nierozerwalnie związana z OO. OO bez polimorfizmu nie jest OO. Wszystkie inne cechy 00 takie, jak:
    <a href="https://pl.wikipedia.org/wiki/Hermetyzacja_(informatyka)">enkapsulacja danych</a>, i metody łączenia się z tymi danymi, i nawet dziedziczenie jest bardziej powiązane z wyrażeniem 1. niż z wyrażeniem 2.
</div>

<div class="paragraphDiv">
    Programiści C i Pascala (i do pewnego stopnia nawet programiści Fortrana i Cobola) od zawsze tworzyli systemy złożone z enkapsulowanych funkcji i struktur danych. Nie wymaga to więc języka
    <a href="https://pl.wikipedia.org/wiki/Obiektowy_j%C4%99zyk_programowania">OOPL</a> żeby tworzyć i używać takich enkapsulowanych struktur. Enkapsulacja i nawet proste dziedziczenie jest oczywiste i naturalne w tego typu językach. (Nawet bardziej naturalne w C i Pascal niż w innych.)
</div>

<div class="paragraphDiv">
    A więc tą rzeczą, która prawdziwie odróżnia programy OO od programów nie-OO jest polimorfizm.
</div>

<div class="paragraphDiv">
    Mógłbyś poskarżyć się mówiąc, że przecież polimorfizm może być osiągnięty poprzez użycie instrukcji switch lub długich łańcuchów if/else w środku <span class="code">f</span>. To prawda, więc muszę dodać jeszcze jedno ograniczenie do OO.
</div>

<div class="paragraphDiv cite">
    Mechanizm polimorfizmu nie może stworzyć zależności w kodzie od wołającego do wołanego.
</div>

<div class="paragraphDiv">
    Dla wyjaśnienia, spójrz jeszcze raz na te dwa wyrażenia. Wyrażenie 1: <span class="code">f(o)</span>, wydaje się posiadać zależność w kodzie do funkcji <span class="code">f</span>. Wnioskujemy to z tego, co już wcześniej wywnioskowaliśmy, że tam jest tylko jedna funkcja <span class="code">f</span> i dlatego wołający musi coś wiedzieć o wołanym.
</div>

<div class="paragraphDiv">
    Natomiast, gdy patrzymy na Wyrażenie 2. <span class="code">o.f()</span> wnioskujemy coś całkiem innego. Wiemy, że może tam być wiele implementacji <span class="code">f</span>, i nie wiemy, która z tych funkcji <span class="code">f</span> zostanie tak naprawdę zawołana. Zatem kod źródłowy, który zawiera Wyrażenie 2. <i>nie ma</i> zależności kodu źródłowego funkcji, która jest wołana.
</div>

<div class="paragraphDiv">
    W bardziej konkretnych pojęciach oznacza to, że moduły (pliki źródłowe), które zawierają polimorficzne wywołania do funkcji nie mogą zależeć, w jakikolwiek sposób, od modułów (plików źródłowych), które zawierają implementacje tych funkcji. Nie może tam być żadnego <span class="code">include</span> czy <span class="code">use</span> czy <span class="code">require</span> ani żadnej innej deklaracji tego typu, która powodowałaby, że jeden plik źródłowy zależy od drugiego.
</div>

<div class="paragraphDiv">
    A więc naszą redukcjonistyczną definicją OO będzie:
</div>

<div class="paragraphDiv cite">
    Technika wywoływania funkcji przy użyciu dynamicznego polimorfizmu, w której kod źródłowy wołający nie zależy od kodu źródłowego wołanego.
</div>

<h3>Co to jest FP?</h3>

<div class="paragraphDiv">
    Znowu, zamierzam być bardzo redukcjonistyczny. FP ma bogatą historię i tradycję, która sięga daleko poza oprogramowanie. Są zasady, techniki, teorie, filozofie i pomysły, które władają tym paradygmatem. Zamierzam zignorować je wszystkie i od razu przejść do sedna, do nierozerwalnego atrybutu, który odgradza FP od każdego innego stylu. I to jest, najprościej, to:
</div>

<div class="paragraphDiv cite">
    <span class="code">f(a) == f(b) kiedy a == b.</span>
</div>

<div class="paragraphDiv">
    W programie funkcyjnym, każdorazowo, gdy konkretną funkcję z konkretną wartością, otrzymujesz ten sam rezultat; nie ważne jak długo będzie działał program. To jest czasami nazywane <a href="https://en.wikipedia.org/wiki/Referential_transparency">"przejrzystością referencyjną"</a>.
</div>

<div class="paragraphDiv">
    Konsekwencje tego są takie, że funnkcja <span class="code">f</span> nie może zmienić żadnego globalnego stanu, który wpływałby na zachowanie funkcji <span class="code">f</span>. Co wiecej, jeżeli założymy, że ta funkcja <span class="code">f</span> reprezentuje wszystkie funkcje w systemie, to
</div>


<div class="smallGreyText">
    <hr />
    <div>Powyższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina ze strony :</div>
    <br/>
    <div><a href="https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html</a></div>
    <br/>
    <div>Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.</div>
    <hr />
</div>
<br/>
