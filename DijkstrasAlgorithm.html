<!DOCTYPE html>

<html>
<head>

    <meta charset="UTF-8">
    <style scoped="scoped" type="text/css">
        .paragraphDiv {
            margin: 0 1em 0.5em 1em;
        }

        img {
            margin: 10px;
        }

        .smallGreyText {
            text-align: center;
            color: #999999;
            font-size: 0.6em;
            margin: 1em 0.1em 1em 0.1em;
        }

        .cite {
            padding: 0 1em 0 1em;
            margin: 1em;
            border-left: solid;
            border-color: #eef2f5;
        }

        .code {
            font-family: monospace;
        }

    </style>

</head>
<body>

<br/>

<div class="paragraphDiv">
    Byłem jednego dnia na <a href="http://scna.softwarecraftsmanship.org/">SCNA</a>, i ktoś zagadnął mnie o TDD i <a
        href="https://pl.wikipedia.org/wiki/Algorytm_Dijkstry">algorytm Dijkstry</a>. Zastanawiał się, czy można znaleźć sekwencję testów, która zaprowadzi do algorytmu. To wyglądało mi na fajne, krótkie ćwiczenie, więc zdecydowałem się spróbować.
</div>

<div class="smallGreyText">
    <hr/>
    <div>
        Poniższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2016/10/26/DijkstrasAlg.html">https://blog.cleancoder.com/uncle-bob/2016/10/26/DijkstrasAlg.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>
<br/>

<div class="paragraphDiv">
    Zacząłem tak, jak zwykle; z odpaleniem ograniczonego przypadku testowego.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">public</span> <span style="font-weight: bold">class</span> <span style="font-weight: bold">MinPathTest</span> {
  @Test
  <span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> nothing() <span style="font-weight: bold">throws</span> Exception {
  }
}
</pre></div>

</div>

<div class="paragraphDiv">
    Algorytm Dijkstry jest prostym sposobem znajdowania najkrótszej drogi w grafie o krawędziach mających konkretną długość. Podając węzeł startowy i końcowy, algorytm wskaże, jaka jest najkrótsza ścieżka i jaka jest jej długość.
</div>

<div class="paragraphDiv">
    A więc już od samego początku są ciekawe decyzje do podjęcia. W jaki sposób powinienem przedstawiać wejściowy graf? Jak powinienem przedstawiać wyjście tego algorytmu? O większości tego możemy prawdopodobnie zadecydować później. Na teraz, powinniśmy skoncentrować się na najbardziej ograniczonym przypadku: pustym grafie.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> noGraph_NoPathZeroLength() <span style="font-weight: bold">throws</span> Exception {
  Assert.assertEquals(<span style="font-style: italic">&quot;{}0&quot;</span>, minPath(<span style="font-style: italic">&quot;&quot;</span>));
}
</pre></div>

</div>

<div class="paragraphDiv">
   Ten pierwszy test zmusił mnie, abym podjął jakieś decyzje o formacie wyjścia. Będę prezentował wyjściową ścieżkę jako zbiór węzłów pomiędzy nawiasami klamrowymi. Długość ścieżki będzie liczbą całkowitą za nawiasami klamrowymi.
</div>

<div class="paragraphDiv">
    Ta notacja jest tylko na potrzeby moich testów. Używam techniki, którą nazywam <i>skomponowanymi asercjami</i>. Lubię komponować moje asercje w zdania, które czyta się łatwo. To zwykle oznacza, że muszę pisać proste translatory, które zamieniają skomponowane asercje na rzeczywiste API systemu poddawanego testom.
</div>

<div class="paragraphDiv">
    To jasne, że mogę sprawić, aby ten test przechodził, nie używając niczego więcej niż tego:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">private</span> String minPath(String graph) {
  <span style="font-weight: bold">return</span> <span style="font-style: italic">&quot;{}0&quot;</span>;
}
</pre></div>

</div>

<div class="paragraphDiv">
    Popatrzmy wnikliwie na ten przypadek testowy. Nie jest właściwe takie wywołanie metody <span class="code">minPath</span>. Algorytm Dijkstry znajduje najkrótszą ścieżkę pomiędzy dwoma określonymi węzłami. Więc zakładając, że węzły mają nazwy, test powinien naprawdę wyglądać jakoś tak:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">Assert.assertEquals(<span style="font-style: italic">&quot;{}0&quot;</span>, minPath(<span style="font-style: italic">&quot;&quot;</span>, <span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
</pre></div>

</div>

<div class="paragraphDiv">
    To brzydko wygląda. Możemy zrefaktorować to tak, aby było odrobinę ładniejsze:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> assertPath(String graph, String expected) {
  assertEquals(expected, minPath(graph, <span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
}

@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> noGraph_NoPathZeroLength() <span style="font-weight: bold">throws</span> Exception {
  assertPath(<span style="font-style: italic">&quot;&quot;</span>, <span style="font-style: italic">&quot;{}0&quot;</span>);
}
</pre></div>

</div>

<div class="paragraphDiv">
    Zauważ, że metoda <span class="code">assertPath</span> dla prostoty zakłada, że wszystkie przypadki testowe będą używać
    <span class="code">"A"</span> i <span class="code">"Z"</span> jako ich pozycji startowych i końcowych.
</div>

<div class="paragraphDiv">
    Jedna, ostatnia zmiana. Myślę, że ścieżka i jej długość powinny być oddzielone.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> assertMinPath(String graph,
                           <span style="font-weight: bold">int</span> length, String path) {
  assertEquals(length, minLength(graph, <span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
  assertEquals(path, minPath(graph, <span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
}

@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> noGraph_NoPathZeroLength() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);
}

<span style="font-weight: bold">private</span> <span style="font-weight: bold">int</span> minLength(String graph, String begin, String end) {
  <span style="font-weight: bold">return</span> 0;
}

<span style="font-weight: bold">private</span> String minPath(String graph, String begin, String end) {
  <span style="font-weight: bold">return</span> <span style="font-style: italic">&quot;{}&quot;</span>;
}
</pre></div>

</div>

<div class="paragraphDiv">
    Ponieważ są dwie metody do sprawdzenia w mojej asercji, myślę, że sensownym byłoby założyć, że powinny one być metodami tej samej klasy uruchamiającej algorytm Dijkstry. Użyjmy więc refaktoringu typu
    <i>wyciągnij delegata</i>, aby wyciągnąć to do nowej klasy.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">public</span> <span style="font-weight: bold">class</span> <span style="font-weight: bold">MinPathTest</span> {
  <span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> assertMinPath(String graph,
                             <span style="font-weight: bold">int</span> length, String path) {
    PathFinder pf = <span style="font-weight: bold">new</span> PathFinder(graph);
    assertEquals(length, pf.minLength(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
    assertEquals(path, pf.minPath(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
  }

  @Test
  <span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> noGraph_NoPathZeroLength() <span style="font-weight: bold">throws</span> Exception {
    assertMinPath(<span style="font-style: italic">&quot;&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);
  }
}

<span style="font-weight: bold">class</span> <span style="font-weight: bold">PathFinder</span> {
  <span style="font-weight: bold">public</span> PathFinder(String graph) {
  }

  <span style="font-weight: bold">public</span> <span style="font-weight: bold">int</span> minLength(String begin, String end) {
    <span style="font-weight: bold">return</span> 0;
  }

  <span style="font-weight: bold">public</span> String minPath(String begin, String end) {
    <span style="font-weight: bold">return</span> <span style="font-style: italic">&quot;{}&quot;</span>;
  }
}
</pre></div>

</div>

<div class="paragraphDiv">
    Uważam to za interesujące, że już tak dużo namysłu i wysiłku zostało włożone w strukturę tego problemu — dla jednego tylko, ograniczonego przypadku testowego. Ale teraz myślę, że możemy dodać kilka innych ograniczonych przypadków:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> degenerateCases() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);   <span style="font-style: italic">//pusty graf</span>
  assertMinPath(<span style="font-style: italic">&quot;A&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);  <span style="font-style: italic">//jeden węzeł</span>
  assertMinPath(<span style="font-style: italic">&quot;B1C&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);<span style="font-style: italic">//nie ma ani początku ani końca</span>
  assertMinPath(<span style="font-style: italic">&quot;A1C&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);<span style="font-style: italic">//nie ma końca</span>
  assertMinPath(<span style="font-style: italic">&quot;B1Z&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);<span style="font-style: italic">//nie ma początku</span>
}
</pre></div>

</div>

<div class="paragraphDiv">
    Te testy zmusiły mnie, aby podjąć kolejną decyzję o <i>skomponowanej asercji</i>. Dla naszych testów struktura krawędzi grafu będzie wyglądała tak:
    <span class="code">&lt;nazwa&gtdługość&lt;nazwa&gt</span>. Więc <span class="code">B1C</span> jest krawędzią o długości <span class="code">1</span>, która łączy węzeł
    <span class="code">B</span> i <span class="code">C</span>.
</div>

<div class="paragraphDiv">
    Myślę, że wszystkie te przypadki testowe są dość ograniczone. Więc przekręćmy koło zębate skomplikowania o jeden ząbek w górę i stwórzmy test, który zmusi nas do zrobienia czegoś choć trochę bardziej sprytnego.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> oneEdge() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;A1Z&quot;</span>, 1, <span style="font-style: italic">&quot;{AZ}&quot;</span>);
}
</pre></div>

</div>

<div class="paragraphDiv">
    Ten test, oczywiście, nie przejdzie. Czuję też pewien dyskomfort, ponieważ testuję dwie rzeczy naraz, długość i ścieżkę, które mogłyby być testowane oddzielnie. Wyjdę teraz na zrzędę, bo poświęciłem tyle czasu na wprowadzenie skomponowanej asercji; i teraz chciałbym ją rozbić znowu.
    Ale myślę, że jest jeden "sprytny" sposób na obejście tego:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">private</span> <span style="font-weight: bold">static</span> String ANY = <span style="font-weight: bold">null</span>;

<span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> assertMinPath(String graph,
                           Integer length, String path) {
  PathFinder pf = <span style="font-weight: bold">new</span> PathFinder(graph);
  <span style="font-weight: bold">if</span> (length != <span style="font-weight: bold">null</span>)
    assertEquals((<span style="font-weight: bold">int</span>)length, pf.minLength(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
  <span style="font-weight: bold">if</span> (path != <span style="font-weight: bold">null</span>)
    assertEquals(path, pf.minPath(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
}
...
@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> oneEdge() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;A1Z&quot;</span>, 1, ANY);
}
</pre></div>

</div>

<div class="paragraphDiv">
    To pozostawia moją skomponowaną asercję nietkniętą, i pozwala mi pominąć dowolną z tych dwóch komponentów na życzenie. A teraz sprawmy, żeby ten test przechodził.
</div>

<div class="paragraphDiv">
    Teraz, oczywiście, mógłbym zrobić coś tak ohydnego, jak to:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">public</span> <span style="font-weight: bold">int</span> minLength(String begin, String end) {
  <span style="font-weight: bold">if</span> (graph.equals(<span style="font-style: italic">&quot;A1Z&quot;</span>))
    <span style="font-weight: bold">return</span> 1;
  <span style="font-weight: bold">return</span> 0;
}
</pre></div>

</div>


<div class="paragraphDiv">
    Ale to łamie kilka zasad. Po pierwsze, to łamie zasadę <em>ogólności</em>, która mówi: <em>W miarę, jak testy robią się
    bardziej konkretne, kod robi się bardziej ogólny</em>. Innymi słowy, kod produkcyjny musi stać się bardziej ogólny, aby spełnić test, który nie przechodzi. Do produkcyjnego kodu nie możesz dodawać wyrażeń, które są specyficzne dla danego testu. (Mówię o tym dużo więcej w
    <a href="https://cleancoders.com/episode/clean-code-episode-19-p1/show">Odcinku 19: Zaawansowane TDD</a>, na <a
        href="https://cleancoders.com/">cleancoders.com</a>)
</div>

<div class="paragraphDiv">
    Drugą złamaną zasadą jest <a href="https://pl.wikipedia.org/wiki/Zale%C5%BCno%C5%9B%C4%87_oprogramowania">zależność</a> testów. Nie chcemy, aby testy stały się mocno zależne od produkcyjnego kodu. Im więcej zależności, tym bardziej testy stają się kruche. Nie chcemy doprowadzić do sytuacji, gdy pojedyncza zmiana w kodzie produkcyjnym zepsuje dziesiątki czy setki testów.
</div>

<div class="paragraphDiv">
    To oznacza, że nie powinienem przekazywać <span class="code">String graph</span> do konstruktora klasy <span
        class="code">PathFinder</span>. To też oznacza, że funkcja <span class="code">minPath</span> nie powinna zwracać
    <span class="code">String</span> używanego przez skomponowaną asercję.
</div>

<div class="paragraphDiv">
    A więc teraz jest czas, aby zacząć uniezależniać testy. Funkcja <span class="code">makePathFinder</span> poniżej pokazuje, jak to zrobiłem.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">public</span> <span style="font-weight: bold">class</span> <span style="font-weight: bold">MinPathTest</span> {
  <span style="font-weight: bold">private</span> <span style="font-weight: bold">static</span> String ANY = <span style="font-weight: bold">null</span>;

  <span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> assertMinPath(String graph,
                             Integer length, String path) {
    PathFinder pf = makePathFinder(graph);
    <span style="font-weight: bold">if</span> (length != <span style="font-weight: bold">null</span>)
      assertEquals((<span style="font-weight: bold">int</span>) length, pf.minLength(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
    <span style="font-weight: bold">if</span> (path != <span style="font-weight: bold">null</span>)
      assertEquals(path, pf.minPath(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>));
  }

  <span style="font-weight: bold">private</span> PathFinder makePathFinder(String graph) {
    PathFinder pf = <span style="font-weight: bold">new</span> PathFinder();
    Pattern edgePattern =
            Pattern.compile(<span style="font-style: italic">&quot;(\\D+)(\\d+)(\\D+)&quot;</span>);
    Matcher matcher = edgePattern.matcher(graph);
    <span style="font-weight: bold">if</span> (matcher.matches()) {
      String start = matcher.group(1);
      <span style="font-weight: bold">int</span> length = Integer.parseInt(matcher.group(2));
      String end = matcher.group(3);
      pf.addEdge(start, end, length);
    }
    <span style="font-weight: bold">return</span> pf;
  }

  @Test
  <span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> degenerateCases() <span style="font-weight: bold">throws</span> Exception {
    assertMinPath(<span style="font-style: italic">&quot;&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);   <span style="font-style: italic">//empty graph</span>
    assertMinPath(<span style="font-style: italic">&quot;A&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);  <span style="font-style: italic">//one node</span>
    assertMinPath(<span style="font-style: italic">&quot;B1C&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);<span style="font-style: italic">//no start or end</span>
    assertMinPath(<span style="font-style: italic">&quot;A1C&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);<span style="font-style: italic">//no end</span>
    assertMinPath(<span style="font-style: italic">&quot;B1Z&quot;</span>, 0, <span style="font-style: italic">&quot;{}&quot;</span>);<span style="font-style: italic">//no start</span>
  }

  @Test
  <span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> oneEdge() <span style="font-weight: bold">throws</span> Exception {
    assertMinPath(<span style="font-style: italic">&quot;A1Z&quot;</span>, 1, ANY);
  }
}

<span style="font-weight: bold">class</span> <span style="font-weight: bold">PathFinder</span> {
  <span style="font-weight: bold">private</span> List&lt;Edge&gt; edges = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;();

  <span style="font-weight: bold">public</span> PathFinder() {
  }

  <span style="font-weight: bold">public</span> <span style="font-weight: bold">int</span> minLength(String begin, String end) {
    <span style="font-weight: bold">int</span> length = 0;
    <span style="font-weight: bold">for</span> (Edge edge : edges) {
      <span style="font-weight: bold">if</span> (edge.begin.equals(begin) &amp;&amp; edge.end.equals(end))
        length += edge.length;
    }
    <span style="font-weight: bold">return</span> length;
  }

  <span style="font-weight: bold">public</span> String minPath(String begin, String end) {
    <span style="font-weight: bold">return</span> <span style="font-style: italic">&quot;{}&quot;</span>;
  }

  <span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> addEdge(String start, String end, <span style="font-weight: bold">int</span> length) {
    edges.add(<span style="font-weight: bold">new</span> Edge(start, end, length));
  }

  <span style="font-weight: bold">private</span> <span style="font-weight: bold">static</span> <span style="font-weight: bold">class</span> <span style="font-weight: bold">Edge</span> {
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> String begin;
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> String end;
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> <span style="font-weight: bold">int</span> length;

    <span style="font-weight: bold">public</span> Edge(String begin, String end, <span style="font-weight: bold">int</span> length) {
      <span style="font-weight: bold">this</span>.begin = begin;
      <span style="font-weight: bold">this</span>.end = end;
      <span style="font-weight: bold">this</span>.length = length;
    }
  }
}
</pre></div>

</div>

<div class="paragraphDiv">
    Zauważ, że całe parsowanie dla skomponowanej asercji pozostaje w klasie testowej. Klasa <span class="code">PathFinder</span> nie wie nic o tej śmiesznej składni, której używam w testach. Zauważ także, że aby testy przechodziły, kod produkcyjny musi zakładać, że wykres ma tylko jedną krawędź. To założenie zamierzamy złamać w kolejnych kilku testach. W międzyczasie powinniśmy pozbyć się tego
    <span class="code">ANY</span>.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">assertMinPath(<span style="font-style: italic">&quot;A1Z&quot;</span>, 1, <span style="font-style: italic">&quot;{AZ}&quot;</span>);
</pre></div>

</div>

<div class="paragraphDiv">
    Więc zamierzam zbudować listę węzłów w ścieżce. Listę? Aaaa, jest składnia <span class="code">toString</span> dla list. Powinniśmy zmienić ten test i wszystkie inne testy następująco:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> degenerateCases() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;&quot;</span>, 0, <span style="font-style: italic">&quot;[]&quot;</span>);   <span style="font-style: italic">//pusty graf</span>
  assertMinPath(<span style="font-style: italic">&quot;A&quot;</span>, 0, <span style="font-style: italic">&quot;[]&quot;</span>);  <span style="font-style: italic">//jeden węzeł</span>
  assertMinPath(<span style="font-style: italic">&quot;B1C&quot;</span>, 0, <span style="font-style: italic">&quot;[]&quot;</span>);<span style="font-style: italic">//nie ma ani początku ani końca</span>
  assertMinPath(<span style="font-style: italic">&quot;A1C&quot;</span>, 0, <span style="font-style: italic">&quot;[]&quot;</span>);<span style="font-style: italic">//nie ma końca</span>
  assertMinPath(<span style="font-style: italic">&quot;B1Z&quot;</span>, 0, <span style="font-style: italic">&quot;[]&quot;</span>);<span style="font-style: italic">//nie ma początku</span>
}

@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> oneEdge() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;A1Z&quot;</span>, 1, <span style="font-style: italic">&quot;[A, Z]&quot;</span>);
}
</pre></div>

</div>

<div class="paragraphDiv">
    Teraz, aby to przechodziło, dodamy w funkcji pomocniczej <span class="code">assertMinPath</span> wywołanie
    <span class="code">toString</span>.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">...
    <span style="font-weight: bold">if</span> (path != <span style="font-weight: bold">null</span>)
      assertEquals(path, pf.minPath(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>).toString());
...
</pre></div>

</div>

<div class="paragraphDiv">
    Dodamy listę węzłów <span class="code">path</span> do <span class="code">PathFindera</span> i po prostu zwrócimy ją w <span class="code">minLength</span>.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">class</span> <span style="font-weight: bold">PathFinder</span> {
  <span style="font-weight: bold">private</span> List&lt;Edge&gt; edges = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;();
  ...

  <span style="font-weight: bold">public</span> <span style="font-weight: bold">int</span> minLength(String begin, String end) {
    <span style="font-weight: bold">int</span> length = 0;
    <span style="font-weight: bold">for</span> (Edge edge : edges) {
      <span style="font-weight: bold">if</span> (edge.begin.equals(begin) &amp;&amp; edge.end.equals(end)) {
        length += edge.length;
        path.add(edge.begin);
        path.add(edge.end);
      }
    }
    <span style="font-weight: bold">return</span> length;
  }

  <span style="font-weight: bold">public</span> List&lt;String&gt; minPath(String begin, String end) {
    <span style="font-weight: bold">return</span> path;
  }
...
</pre></div>

</div>

<div class="paragraphDiv">
    To działa. Ale nie podoba mi się fakt, że <span class="code">minLength</span> również oblicza ścieżkę. Myślę, że powinniśmy oddzielić obliczenia od raportowania.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">  <span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> assertMinPath(String graph,
                             Integer length, String path) {
    PathFinder pf = makePathFinder(graph);
    <span style="font-weight: bold">if</span> (length != <span style="font-weight: bold">null</span>)
      assertEquals((<span style="font-weight: bold">int</span>) length, pf.getLength());
    <span style="font-weight: bold">if</span> (path != <span style="font-weight: bold">null</span>)
      assertEquals(path, pf.getPath().toString());
  }

  <span style="font-weight: bold">private</span> PathFinder makePathFinder(String graph) {
    PathFinder pf = <span style="font-weight: bold">new</span> PathFinder();
    ...
    pf.findPath(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>);
    <span style="font-weight: bold">return</span> pf;
  }

<span style="font-weight: bold">class</span> <span style="font-weight: bold">PathFinder</span> {
  <span style="font-weight: bold">private</span> List&lt;Edge&gt; edges = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;();
  <span style="font-weight: bold">private</span> List&lt;String&gt; path = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;();
  <span style="font-weight: bold">private</span> <span style="font-weight: bold">int</span> length;

  ...

  <span style="font-weight: bold">public</span> <span style="font-weight: bold">int</span> getLength() {
    <span style="font-weight: bold">return</span> length;
  }

  <span style="font-weight: bold">public</span> List&lt;String&gt; getPath() {
    <span style="font-weight: bold">return</span> path;
  }

...
</pre></div>

</div>

<div class="paragraphDiv">
    OK, teraz lepiej. Teraz, upewnijmy się, że dostajemy prawidłową długość.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">assertMinPath(<span style="font-style: italic">&quot;A2Z&quot;</span>, 2, <span style="font-style: italic">&quot;[A, Z]&quot;</span>);
</pre></div>

</div>


<div class="paragraphDiv">
    Taaa, to działa całkiem nieźle. Więc spróbujmy dwóch następujących po sobie krawędzi.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> twoEdges() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;A1B,B1Z&quot;</span>, 2, ANY);
}
</pre></div>

</div>

<div class="paragraphDiv">
    To nie przechodzi, jak należało się spodziewać, dając nam w wyniku długość zero. Aby to przechodziło, musimy umieć parsować wiele krawędzi w funkcji pomocniczej <span class="code">makePathFinder</span>. To jest całkiem proste. Tylko podziel graf na przecinkach, i wrzuć dopasowanie wyrażeń regularnych w pętlę.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">private</span> PathFinder makePathFinder(String graph) {
  PathFinder pf = <span style="font-weight: bold">new</span> PathFinder();
  Pattern edgePattern = Pattern.compile(<span style="font-style: italic">&quot;(\\D+)(\\d+)(\\D+)&quot;</span>);
  String[] edges = graph.split(<span style="font-style: italic">&quot;,&quot;</span>);
  <span style="font-weight: bold">for</span> (String edge : edges) {
    Matcher matcher = edgePattern.matcher(edge);
    <span style="font-weight: bold">if</span> (matcher.matches()) {
      String start = matcher.group(1);
      <span style="font-weight: bold">int</span> length = Integer.parseInt(matcher.group(2));
      String end = matcher.group(3);
      pf.addEdge(start, end, length);
    }
  }
  pf.findPath(<span style="font-style: italic">&quot;A&quot;</span>, <span style="font-style: italic">&quot;Z&quot;</span>);
  <span style="font-weight: bold">return</span> pf;
}
</pre></div>

</div>

<div class="paragraphDiv">
    Oczywiście to nadal nie sprawia, że test przechodzi, więc teraz zamierzamy połączyć dwie krawędzie. Załóżmy, że krawędzie są ułożone po kolei, więc wierzchołek A rozpoczyna pierwszą krawędź, i wierzchołek Z kończy drugą krawędź. Przy takim założeniu, możemy ustawić całe połączenie poprzez zmianę warunku <span class="code">&&</span> na <span class="code">||</span> w funkcji <span class="code">findPath</span>:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> findPath(String begin, String end) {
  length = 0;
  <span style="font-weight: bold">for</span> (Edge edge : edges) {
    <span style="font-weight: bold">if</span> (edge.begin.equals(begin) || edge.end.equals(end)) {
      length += edge.length;
      path.add(edge.begin);
      path.add(edge.end);
    }
  }
}
</pre></div>

</div>

<div class="paragraphDiv">
    Podoba Ci się ta zmiana? <span class="code">&&</span> na <span class="code">||</span>. Taaak, całkiem sprytnie. To zadziała tylko dla dwóch kolejnych krawędzi. Założenia wznoszą się w niebiosa! I, tak czy inaczej, to nie działa.
</div>

<div class="paragraphDiv">
    Ooo, przechodzą testy <span class="code">twoEdges</span>, i testy <span class="code">oneEdge</span>, ale nie przechodzą testy
    <span class="code">degenerateCases</span>. I to nie dziwota, ponieważ tylko nasze dwa ostatnie ograniczone przypadki testowe pasują do założenia "A" pierwszy lub "Z" ostatni.
</div>

<div class="paragraphDiv">
    Aby wszystkie te testy przechodziły, potrzebuję implementacji, która w wyniku daje zerową długość i pustą ścieżkę, jeżeli nie istnieje ścieżka pomiędzy A i Z. Ponieważ nie wiem, ile będzie krawędzi (może być zero, jeden, dwie) nie mogę wziąć tylko dwóch. Zamiast tego, mógłbym zrobić analizę przypadków dla zera, jednej lub dwóch krawędzi; jak poniżej:
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> findPath(String begin, String end) {
  <span style="font-weight: bold">if</span> (edges.size() == 0)
    <span style="font-weight: bold">return</span>;

  <span style="font-weight: bold">else</span> if (edges.size() == 1) {
    Edge edge = edges.get(0);
    <span style="font-weight: bold">if</span> (edge.begin.equals(begin) &amp;&amp; edge.end.equals(end)) {
      path.add(edge.begin);
      path.add(edge.end);
      length += edge.length;
    }
  } <span style="font-weight: bold">else</span> {
    <span style="font-weight: bold">for</span> (Edge edge : edges) {
      <span style="font-weight: bold">if</span> (edge.begin.equals(begin) || edge.end.equals(end)) {
        path.add(edge.begin);
        path.add(edge.end);
        length += edge.length;
      }
    }
  }
}
</pre></div>

</div>

<div class="paragraphDiv">
    OK, to działa, ale to jest naprawdę okropne. Nie tylko łamie zasadę <em>ogólności</em>; to jest po prostu ohydne. Co więcej, nie do końca poprawnie tworzy ścieżkę. Na przykład test: <span class="code">assertMinPath("A1B,B1Z", 2, "[A, B, Z]");</span> nie przechodzi, ponieważ tworzy <span class="code">[A, B, B, Z]</span>. Mógłbym to naprawić przez dodanie jeszcze jednej okropnej instrukcji
    <span class="code">if</span>; ale mam lepszy pomysł. Przejdźmy graf od początku do końca.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> findPath(String begin, String end) {
  List&lt;String&gt; p = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;();
  <span style="font-weight: bold">int</span> l = 0;
  p.add(begin);

  <span style="font-weight: bold">for</span> (Edge e = findEdge(begin);
       e != <span style="font-weight: bold">null</span>; e = findEdge(e.end)) {
    p.add(e.end);
    l += e.length;
    <span style="font-weight: bold">if</span> (e.end.equals(end)) {
      length = l;
      path = p;
      <span style="font-weight: bold">return</span>;
    }
  }
}

<span style="font-weight: bold">private</span> Edge findEdge(String begin) {
  <span style="font-weight: bold">for</span> (Edge e : edges) {
    <span style="font-weight: bold">if</span> (e.begin.equals(begin))
      <span style="font-weight: bold">return</span> e;
  }
  <span style="font-weight: bold">return</span> <span style="font-weight: bold">null</span>;
}
</pre></div>

</div>

<div class="paragraphDiv">
    OK, działa. To osobliwe, że musieliśmy użyć tymczasowych zmiennych <span class="code">length</span> i <span
        class="code">path</span>; ale to jedyny sposób, jaki przychodzi mi na myśl, na ignorowanie ścieżek, które nie istnieją. Myślę także, że to rozwiązanie pozbawia nas zależności od kolejności.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> twoEdges() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;A1B,B1Z&quot;</span>, 2, <span style="font-style: italic">&quot;[A, B, Z]&quot;</span>);
  assertMinPath(<span style="font-style: italic">&quot;B1Z,A1B&quot;</span>, 2, <span style="font-style: italic">&quot;[A, B, Z]&quot;</span>);
  assertMinPath(<span style="font-style: italic">&quot;A1X,Y1Z&quot;</span>, 0, <span style="font-style: italic">&quot;[]&quot;</span>);
}
</pre></div>

</div>

<div class="paragraphDiv">
    Tak, wszystkie przechodzą. Myślę, że trzy i więcej krawędzi też zadziała. I także grafy z jedną kompletną ścieżką i pozostałymi dyndającymi ścieżkami.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> threeEdges() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;A2B,B3C,C4Z&quot;</span>, 9, <span style="font-style: italic">&quot;[A, B, C, Z]&quot;</span>);
  assertMinPath(<span style="font-style: italic">&quot;B3C,C4Z,A2B&quot;</span>, 9, <span style="font-style: italic">&quot;[A, B, C, Z]&quot;</span>);
}

@Test
<span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> OnlyOnePath() <span style="font-weight: bold">throws</span> Exception {
  assertMinPath(<span style="font-style: italic">&quot;A1B,B2C,C3Z,B4D,D6E&quot;</span>, 6, <span style="font-style: italic">&quot;[A, B, C, Z]&quot;</span>);
}
</pre></div>

</div>

<div class="paragraphDiv">
    Ale to nie będzie przechodzić, ponieważ przejście przez graf pomija krawędź <span class="code">C3Z</span>.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">assertMinPath(<span style="font-style: italic">&quot;A1B,B2C,C3D,C3Z&quot;</span>, 6, <span style="font-style: italic">&quot;[A, B, C, Z]&quot;</span>);
</pre></div>

</div>

<div class="paragraphDiv">
    Ok. Więc nie możemy po prostu przejść grafu po kolei. W zamian to, co musimy zrobić, to sprawdzić każdą możliwą drogę, która wychodzi z wierzchołka startowego; i przez całą tę drogę musimy zapisywać nasze tymczasowe znaleziska, aż dojdziemy do końca.
</div>

<div class="paragraphDiv">
    Jak zobaczysz poniżej, to wymaga odrobinę mrówczego wysiłku. Muszę śledzić wszystkie wierzchołki, i ścieżki i długości połączone z tymi wierzchołkami. Ale, poza tym, algorytm jest prawie taki sam jak do tej pory.
</div>


<div class="paragraphDiv">
    Iteracja w pętli jest inna. Zaczyna się w początkowym wierzchołku, i potem przechodzi przez wszystkich <em>nieodwiedzonych</em> sąsiadów, i zapisuje dodane długości i ścieżki w tych sąsiadach.
</div>

<div class="paragraphDiv">
    Zauważ, że użyłem <span class="code">Integer.MAX_VALUE</span> jako strażnika, który oznacza "Nieodwiedzony z odwiedzonego wierzchołka". Ograniczamy limit wyszukiwania do tylko tych wierzchołków, które były odwiedzone, ponieważ przecież idziemy od początku do końca. Każdy węzeł, który nie był odwiedzony, oczywiście, nie może być <em>następnym</em> w ścieżce.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">class</span> <span style="font-weight: bold">PathFinder</span> {
  <span style="font-weight: bold">private</span> List&lt;Edge&gt; edges = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;();
  <span style="font-weight: bold">private</span> Set&lt;String&gt; nodeNames = <span style="font-weight: bold">new</span> HashSet&lt;&gt;();
  <span style="font-weight: bold">private</span> Map&lt;String, Node&gt; nodes = <span style="font-weight: bold">new</span> HashMap&lt;&gt;();
  <span style="font-weight: bold">private</span> Node endNode;

  <span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> findPath(String begin, String end) {
    List&lt;String&gt; unvisited = initializeSearch(begin, end);

    <span style="font-weight: bold">for</span> (String node = begin;
	     node != <span style="font-weight: bold">null</span>; node = getNext(unvisited)) {
      unvisited.remove(node);
      visit(node);
    }

    setupEndNode(end);
  }

  <span style="font-weight: bold">private</span> List&lt;String&gt; initializeSearch(String begin,
	                                    String end) {
    nodeNames.add(begin);
    nodeNames.add(end);
    List&lt;String&gt; unvisited = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;(nodeNames);
    <span style="font-weight: bold">for</span> (String node : unvisited)
      nodes.put(node, <span style="font-weight: bold">new</span> Node(Integer.MAX_VALUE));

    nodes.get(begin).length = 0;
    <span style="font-weight: bold">return</span> unvisited;
  }

  <span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> visit(String node) {
    List&lt;Edge&gt; neighbors = findEdges(node);
    Node curNode = nodes.get(node);
    <span style="font-weight: bold">for</span> (Edge e : neighbors) {
      Node nbr = nodes.get(e.end);
      nbr.length = curNode.length + e.length;
      nbr.path = <span style="font-weight: bold">new</span> ArrayList&lt;String&gt;();
      nbr.path.addAll(curNode.path);
      nbr.path.add(node);
    }
  }

  <span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> setupEndNode(String end) {
    endNode = nodes.get(end);
    <span style="font-weight: bold">if</span> (endNode.length != Integer.MAX_VALUE)
      endNode.path.add(end);
    <span style="font-weight: bold">else</span>
      endNode.length = 0;
  }

  <span style="font-weight: bold">private</span> String getNext(List&lt;String&gt; unvisited) {
    <span style="font-weight: bold">for</span> (String name : unvisited) {
      Node candidate = nodes.get(name);
      <span style="font-weight: bold">if</span> (candidate.length != Integer.MAX_VALUE)
        <span style="font-weight: bold">return</span> name;
    }
    <span style="font-weight: bold">return</span> <span style="font-weight: bold">null</span>;
  }

  <span style="font-weight: bold">private</span> List&lt;Edge&gt; findEdges(String begin) {
    List&lt;Edge&gt; found = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;();
    <span style="font-weight: bold">for</span> (Edge e : edges) {
      <span style="font-weight: bold">if</span> (e.begin.equals(begin))
        found.add(e);
    }
    <span style="font-weight: bold">return</span> found;
  }

  <span style="font-weight: bold">public</span> <span style="font-weight: bold">int</span> getLength() {
    <span style="font-weight: bold">return</span> endNode.length;
  }

  <span style="font-weight: bold">public</span> List&lt;String&gt; getPath() {
    <span style="font-weight: bold">return</span> endNode.path;
  }

  <span style="font-weight: bold">public</span> <span style="font-weight: bold">void</span> addEdge(String start, String end, <span style="font-weight: bold">int</span> length) {
    edges.add(<span style="font-weight: bold">new</span> Edge(start, end, length));
    nodeNames.add(start);
    nodeNames.add(end);
  }

  <span style="font-weight: bold">private</span> <span style="font-weight: bold">static</span> <span style="font-weight: bold">class</span> <span style="font-weight: bold">Edge</span> {
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> String begin;
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> String end;
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> <span style="font-weight: bold">int</span> length;

    <span style="font-weight: bold">public</span> Edge(String begin, String end, <span style="font-weight: bold">int</span> length) {
      <span style="font-weight: bold">this</span>.begin = begin;
      <span style="font-weight: bold">this</span>.end = end;
      <span style="font-weight: bold">this</span>.length = length;
    }
  }

  <span style="font-weight: bold">private</span> <span style="font-weight: bold">static</span> <span style="font-weight: bold">class</span> <span style="font-weight: bold">Node</span> {
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">int</span> length;
    <span style="font-weight: bold">public</span> List&lt;String&gt; path;

    <span style="font-weight: bold">public</span> Node(<span style="font-weight: bold">int</span> l) {
      <span style="font-weight: bold">this</span>.length = l;
      <span style="font-weight: bold">this</span>.path = <span style="font-weight: bold">new</span> ArrayList&lt;&gt;();
    }
  }
}
</pre></div>

</div>

<div class="paragraphDiv">
    To przechodzi. Więc teraz potrzebujemy dodać test grafu, który ma równoległe ścieżki. Tu mam jeden prosty, który powinien nie przechodzić:
</div>


<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">assertMinPath(<span style="font-style: italic">&quot;A1B,B2Z,A1Z&quot;</span>, 1, <span style="font-style: italic">&quot;[A, Z]&quot;</span>);
</pre></div>

</div>

<div class="paragraphDiv">
    I nie przechodzi
</div>

<div class="paragraphDiv">
    Aby sprawić, żeby to przechodziło, musimy wykryć, czy dwie ścieżki zbiegają się w jednym węźle. To proste. Jeżeli długość na węźle docelowym nie wynosi
    <span class="code">Integer.MAX_VALUE</span> to oznacza, że inna ścieżka już osiągnęła ten węzeł. Ponieważ szukamy minimum, możemy po prostu ustawić długość na tym węźle na minimalną wartość spośród zbiegających się w tym węźle ścieżek. Wartość <span class="code">Integer.MAX_VALUE</span> wydaje się byc bardzo przydatna dla tego sprawdzenia, ponieważ jest zamiennikiem dla "nieskończonej" długości.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">private</span> <span style="font-weight: bold">void</span> visit(String node) {
  List&lt;Edge&gt; neighbors = findEdges(node);
  Node curNode = nodes.get(node);
  <span style="font-weight: bold">for</span> (Edge e : neighbors) {
    Node nbr = nodes.get(e.end);

    <span style="font-weight: bold">int</span> newLength = curNode.length + e.length;
    <span style="font-weight: bold">if</span> (nbr.length &gt; newLength) {
      nbr.length = newLength;
      nbr.path = <span style="font-weight: bold">new</span> ArrayList&lt;String&gt;();
      nbr.path.addAll(curNode.path);
      nbr.path.add(node);
    }
  }
}
</pre></div>

</div>

<div class="paragraphDiv">
    Prawdopodobnie możemy przyspieszyć troszkę algorytm, kończąc poszukiwania, kiedy osiągniemy węzeł końcowy.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">for</span> (String node = begin; node != <span style="font-weight: bold">null</span> &amp;&amp; !node.equals(end); node = getNext(unvisited)) {
  unvisited.remove(node);
  visit(node);
}
</pre></div>

</div>

<div class="paragraphDiv">
    I zapewne możemy przyspieszyć algorytm nawet bardziej przez preferowanie przeszukiwania nieodwiedzonych węzłów, które zostały odwiedzone przez najkrótszą ścieżkę.
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">private</span> String getNext(List&lt;String&gt; unvisited) {
  String minNodeName = <span style="font-weight: bold">null</span>;
  <span style="font-weight: bold">int</span> minLength = Integer.MAX_VALUE;

  <span style="font-weight: bold">for</span> (String name : unvisited) {
    Node candidate = nodes.get(name);
    <span style="font-weight: bold">if</span> (candidate.length &lt; minLength) {
      minLength = candidate.length;
      minNodeName = name;
    }
  }
  <span style="font-weight: bold">return</span> minNodeName;
}
</pre></div>

</div>

<div class="paragraphDiv">
    To, w każdym możliwym sensie, <em>jest</em> algorytm Dijkstry. Ta implementacja nie jest szybka, ponieważ użyłem zbiorów i list, i mnóstwa nieefektywnych struktur. Przyspieszenie tego zajęłoby całkiem sporo roboty. Co więcej, są tam wbudowane pewne założenia, które należałoby naprawić. Przede wszystkim, jest założenie, że graf wejściowy musi być <a href="https://pl.wikipedia.org/wiki/Graf_skierowany">skierowany</a>; natomiast ogólny algorytm nie wymaga takiego założenia. Na koniec, całości przydałaby się odrobina refaktoringu.
</div>

<div class="paragraphDiv">
    Ale celem było zobaczenie, czy możliwe jest wykorzystanie TDD do dojścia do algorytmu Dijkstry krok po kroku. Moim zdaniem jest możliwe; chociaż, muszę przyznać, że to podejście było trochę szarpane. Te kilka początkowych testów prowadziły mnie przez rząd niepewnych algorytmów, które nie bardzo chciały ewoluować jeden w drugi. Nie mniej, każdy nowy test ujawniał słabości we wcześniejszych implementacjach, które mogły być naprawione w stosunkowo prosty sposób.
</div>

<div class="paragraphDiv">
    Czy jest lepsza sekwencja testów, która prowadzi bardziej wprost do algorytmu Dijkstry, bez tej niepewnej szarpaniny? Być może; ale jeśli tak, nie znalazłem ich.
</div>

<div class="paragraphDiv">
    Mimo wszystko, to było zabawne ćwiczenie. Dziękuję uczestnikowi SCNA za zaproponowanie tego.
</div>

<div class="paragraphDiv">
    Końcowy kod, który nadal potrzebuje troszeczkę posprzątania (pozostawiam czytelnikowi jako ćwiczenie ;-)
</div>

<div class="paragraphDiv">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">package</span> dijkstrasAlg<span style="font-weight: bold">;</span>

<span style="font-weight: bold">import</span> <span style="color: #555555">org.junit.Test</span><span style="font-weight: bold">;</span>

<span style="font-weight: bold">import</span> <span style="color: #555555">java.util.*</span><span style="font-weight: bold">;</span>
<span style="font-weight: bold">import</span> <span style="color: #555555">java.util.regex.Matcher</span><span style="font-weight: bold">;</span>
<span style="font-weight: bold">import</span> <span style="color: #555555">java.util.regex.Pattern</span><span style="font-weight: bold">;</span>

<span style="font-weight: bold">import</span> <span style="color: #555555">static</span> org<span style="font-weight: bold">.</span><span style="color: #008080">junit</span><span style="font-weight: bold">.</span><span style="color: #008080">Assert</span><span style="font-weight: bold">.</span><span style="color: #008080">assertEquals</span><span style="font-weight: bold">;</span>

<span style="font-weight: bold">public</span> <span style="font-weight: bold">class</span> <span style="color: #445588; font-weight: bold">MinPathTest</span> <span style="font-weight: bold">{</span>
  <span style="font-weight: bold">private</span> <span style="font-weight: bold">static</span> String ANY <span style="font-weight: bold">=</span> <span style="font-weight: bold">null;</span>

  <span style="font-weight: bold">private</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">assertMinPath</span><span style="font-weight: bold">(</span>String graph<span style="font-weight: bold">,</span>
                             Integer length<span style="font-weight: bold">,</span> String path<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    PathFinder pf <span style="font-weight: bold">=</span> makePathFinder<span style="font-weight: bold">(</span>graph<span style="font-weight: bold">);</span>
    <span style="font-weight: bold">if</span> <span style="font-weight: bold">(</span>length <span style="font-weight: bold">!=</span> <span style="font-weight: bold">null)</span>
      assertEquals<span style="font-weight: bold">((</span><span style="color: #445588; font-weight: bold">int</span><span style="font-weight: bold">)</span> length<span style="font-weight: bold">,</span> pf<span style="font-weight: bold">.</span><span style="color: #008080">getLength</span><span style="font-weight: bold">());</span>
    <span style="font-weight: bold">if</span> <span style="font-weight: bold">(</span>path <span style="font-weight: bold">!=</span> <span style="font-weight: bold">null)</span>
      assertEquals<span style="font-weight: bold">(</span>path<span style="font-weight: bold">,</span> pf<span style="font-weight: bold">.</span><span style="color: #008080">getPath</span><span style="font-weight: bold">().</span><span style="color: #008080">toString</span><span style="font-weight: bold">());</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">private</span> PathFinder <span style="color: #990000; font-weight: bold">makePathFinder</span><span style="font-weight: bold">(</span>String graph<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    PathFinder pf <span style="font-weight: bold">=</span> <span style="font-weight: bold">new</span> PathFinder<span style="font-weight: bold">();</span>
    Pattern edgePattern <span style="font-weight: bold">=</span>
            Pattern<span style="font-weight: bold">.</span><span style="color: #008080">compile</span><span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;(\\D+)(\\d+)(\\D+)&quot;</span><span style="font-weight: bold">);</span>
    String<span style="font-weight: bold">[]</span> edges <span style="font-weight: bold">=</span> graph<span style="font-weight: bold">.</span><span style="color: #008080">split</span><span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;,&quot;</span><span style="font-weight: bold">);</span>
    <span style="font-weight: bold">for</span> <span style="font-weight: bold">(</span>String edge <span style="font-weight: bold">:</span> edges<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
      Matcher matcher <span style="font-weight: bold">=</span> edgePattern<span style="font-weight: bold">.</span><span style="color: #008080">matcher</span><span style="font-weight: bold">(</span>edge<span style="font-weight: bold">);</span>
      <span style="font-weight: bold">if</span> <span style="font-weight: bold">(</span>matcher<span style="font-weight: bold">.</span><span style="color: #008080">matches</span><span style="font-weight: bold">())</span> <span style="font-weight: bold">{</span>
        String start <span style="font-weight: bold">=</span> matcher<span style="font-weight: bold">.</span><span style="color: #008080">group</span><span style="font-weight: bold">(</span><span style="color: #009999">1</span><span style="font-weight: bold">);</span>
        <span style="color: #445588; font-weight: bold">int</span> length <span style="font-weight: bold">=</span> Integer<span style="font-weight: bold">.</span><span style="color: #008080">parseInt</span><span style="font-weight: bold">(</span>matcher<span style="font-weight: bold">.</span><span style="color: #008080">group</span><span style="font-weight: bold">(</span><span style="color: #009999">2</span><span style="font-weight: bold">));</span>
        String end <span style="font-weight: bold">=</span> matcher<span style="font-weight: bold">.</span><span style="color: #008080">group</span><span style="font-weight: bold">(</span><span style="color: #009999">3</span><span style="font-weight: bold">);</span>
        pf<span style="font-weight: bold">.</span><span style="color: #008080">addEdge</span><span style="font-weight: bold">(</span>start<span style="font-weight: bold">,</span> end<span style="font-weight: bold">,</span> length<span style="font-weight: bold">);</span>
      <span style="font-weight: bold">}</span>
    <span style="font-weight: bold">}</span>
    pf<span style="font-weight: bold">.</span><span style="color: #008080">findPath</span><span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A&quot;</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;Z&quot;</span><span style="font-weight: bold">);</span>
    <span style="font-weight: bold">return</span> pf<span style="font-weight: bold">;</span>
  <span style="font-weight: bold">}</span>

  @Test
  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">degenerateCases</span><span style="font-weight: bold">()</span> <span style="font-weight: bold">throws</span> Exception <span style="font-weight: bold">{</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">0</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[]&quot;</span><span style="font-weight: bold">);</span>   <span style="color: #999988; font-style: italic">//empty graph</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">0</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[]&quot;</span><span style="font-weight: bold">);</span>  <span style="color: #999988; font-style: italic">//one node</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;B1C&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">0</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[]&quot;</span><span style="font-weight: bold">);</span><span style="color: #999988; font-style: italic">//no start or end</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A1C&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">0</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[]&quot;</span><span style="font-weight: bold">);</span><span style="color: #999988; font-style: italic">//no end</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;B1Z&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">0</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[]&quot;</span><span style="font-weight: bold">);</span><span style="color: #999988; font-style: italic">//no start</span>
  <span style="font-weight: bold">}</span>

  @Test
  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">oneEdge</span><span style="font-weight: bold">()</span> <span style="font-weight: bold">throws</span> Exception <span style="font-weight: bold">{</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A1Z&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">1</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, Z]&quot;</span><span style="font-weight: bold">);</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A2Z&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">2</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, Z]&quot;</span><span style="font-weight: bold">);</span>
  <span style="font-weight: bold">}</span>

  @Test
  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">twoEdges</span><span style="font-weight: bold">()</span> <span style="font-weight: bold">throws</span> Exception <span style="font-weight: bold">{</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A1B,B1Z&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">2</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, B, Z]&quot;</span><span style="font-weight: bold">);</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;B1Z,A1B&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">2</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, B, Z]&quot;</span><span style="font-weight: bold">);</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A1X,Y1Z&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">0</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[]&quot;</span><span style="font-weight: bold">);</span>
  <span style="font-weight: bold">}</span>

  @Test
  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">threeEdges</span><span style="font-weight: bold">()</span> <span style="font-weight: bold">throws</span> Exception <span style="font-weight: bold">{</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A2B,B3C,C4Z&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">9</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, B, C, Z]&quot;</span><span style="font-weight: bold">);</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;B3C,C4Z,A2B&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">9</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, B, C, Z]&quot;</span><span style="font-weight: bold">);</span>
  <span style="font-weight: bold">}</span>

  @Test
  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">OnlyOnePath</span><span style="font-weight: bold">()</span> <span style="font-weight: bold">throws</span> Exception <span style="font-weight: bold">{</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A1B,B2C,C3Z,B4D,D6E&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">6</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, B, C, Z]&quot;</span><span style="font-weight: bold">);</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A1B,B2C,C3D,C3Z&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">6</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, B, C, Z]&quot;</span><span style="font-weight: bold">);</span>
  <span style="font-weight: bold">}</span>

  @Test
  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">parallelPaths</span><span style="font-weight: bold">()</span> <span style="font-weight: bold">throws</span> Exception <span style="font-weight: bold">{</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A1B,B2Z,A1Z&quot;</span><span style="font-weight: bold">,</span> <span style="color: #009999">1</span><span style="font-weight: bold">,</span> <span style="color: #bb8844">&quot;[A, Z]&quot;</span><span style="font-weight: bold">);</span>
    assertMinPath<span style="font-weight: bold">(</span><span style="color: #bb8844">&quot;A1B,A1C,A2D,C5E,B8E,C1F,D3F,F2G,G3Z,E2G&quot;</span><span style="font-weight: bold">,</span>
                   <span style="color: #009999">7</span><span style="font-weight: bold">,</span><span style="color: #bb8844">&quot;[A, C, F, G, Z]&quot;</span><span style="font-weight: bold">);</span>
  <span style="font-weight: bold">}</span>
<span style="font-weight: bold">}</span>

<span style="font-weight: bold">class</span> <span style="color: #445588; font-weight: bold">PathFinder</span> <span style="font-weight: bold">{</span>
  <span style="font-weight: bold">private</span> List<span style="font-weight: bold">&lt;</span>Edge<span style="font-weight: bold">&gt;</span> edges <span style="font-weight: bold">=</span> <span style="font-weight: bold">new</span> ArrayList<span style="font-weight: bold">&lt;&gt;();</span>
  <span style="font-weight: bold">private</span> Set<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">&gt;</span> nodeNames <span style="font-weight: bold">=</span> <span style="font-weight: bold">new</span> HashSet<span style="font-weight: bold">&lt;&gt;();</span>
  <span style="font-weight: bold">private</span> Map<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">,</span> Node<span style="font-weight: bold">&gt;</span> nodes <span style="font-weight: bold">=</span> <span style="font-weight: bold">new</span> HashMap<span style="font-weight: bold">&lt;&gt;();</span>
  <span style="font-weight: bold">private</span> Node endNode<span style="font-weight: bold">;</span>

  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">findPath</span><span style="font-weight: bold">(</span>String begin<span style="font-weight: bold">,</span> String end<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    List<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">&gt;</span> unvisited <span style="font-weight: bold">=</span> initializeSearch<span style="font-weight: bold">(</span>begin<span style="font-weight: bold">,</span> end<span style="font-weight: bold">);</span>

    <span style="font-weight: bold">for</span> <span style="font-weight: bold">(</span>String node <span style="font-weight: bold">=</span> begin<span style="font-weight: bold">;</span>
	     node <span style="font-weight: bold">!=</span> <span style="font-weight: bold">null</span> <span style="font-weight: bold">&amp;&amp;</span> <span style="font-weight: bold">!</span>node<span style="font-weight: bold">.</span><span style="color: #008080">equals</span><span style="font-weight: bold">(</span>end<span style="font-weight: bold">);</span>
	     node <span style="font-weight: bold">=</span> getNext<span style="font-weight: bold">(</span>unvisited<span style="font-weight: bold">))</span> <span style="font-weight: bold">{</span>
      unvisited<span style="font-weight: bold">.</span><span style="color: #008080">remove</span><span style="font-weight: bold">(</span>node<span style="font-weight: bold">);</span>
      visit<span style="font-weight: bold">(</span>node<span style="font-weight: bold">);</span>
    <span style="font-weight: bold">}</span>

    setupEndNode<span style="font-weight: bold">(</span>end<span style="font-weight: bold">);</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">private</span> List<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">&gt;</span> <span style="color: #990000; font-weight: bold">initializeSearch</span><span style="font-weight: bold">(</span>String begin<span style="font-weight: bold">,</span>
	                                    String end<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    nodeNames<span style="font-weight: bold">.</span><span style="color: #008080">add</span><span style="font-weight: bold">(</span>begin<span style="font-weight: bold">);</span>
    nodeNames<span style="font-weight: bold">.</span><span style="color: #008080">add</span><span style="font-weight: bold">(</span>end<span style="font-weight: bold">);</span>
    List<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">&gt;</span> unvisited <span style="font-weight: bold">=</span> <span style="font-weight: bold">new</span> ArrayList<span style="font-weight: bold">&lt;&gt;(</span>nodeNames<span style="font-weight: bold">);</span>
    <span style="font-weight: bold">for</span> <span style="font-weight: bold">(</span>String node <span style="font-weight: bold">:</span> unvisited<span style="font-weight: bold">)</span>
      nodes<span style="font-weight: bold">.</span><span style="color: #008080">put</span><span style="font-weight: bold">(</span>node<span style="font-weight: bold">,</span> <span style="font-weight: bold">new</span> Node<span style="font-weight: bold">(</span>Integer<span style="font-weight: bold">.</span><span style="color: #008080">MAX_VALUE</span><span style="font-weight: bold">));</span>

    nodes<span style="font-weight: bold">.</span><span style="color: #008080">get</span><span style="font-weight: bold">(</span>begin<span style="font-weight: bold">).</span><span style="color: #008080">length</span> <span style="font-weight: bold">=</span> <span style="color: #009999">0</span><span style="font-weight: bold">;</span>
    <span style="font-weight: bold">return</span> unvisited<span style="font-weight: bold">;</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">private</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">visit</span><span style="font-weight: bold">(</span>String node<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    List<span style="font-weight: bold">&lt;</span>Edge<span style="font-weight: bold">&gt;</span> neighbors <span style="font-weight: bold">=</span> findEdges<span style="font-weight: bold">(</span>node<span style="font-weight: bold">);</span>
    Node curNode <span style="font-weight: bold">=</span> nodes<span style="font-weight: bold">.</span><span style="color: #008080">get</span><span style="font-weight: bold">(</span>node<span style="font-weight: bold">);</span>
    <span style="font-weight: bold">for</span> <span style="font-weight: bold">(</span>Edge e <span style="font-weight: bold">:</span> neighbors<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
      Node nbr <span style="font-weight: bold">=</span> nodes<span style="font-weight: bold">.</span><span style="color: #008080">get</span><span style="font-weight: bold">(</span>e<span style="font-weight: bold">.</span><span style="color: #008080">end</span><span style="font-weight: bold">);</span>

      <span style="color: #445588; font-weight: bold">int</span> newLength <span style="font-weight: bold">=</span> curNode<span style="font-weight: bold">.</span><span style="color: #008080">length</span> <span style="font-weight: bold">+</span> e<span style="font-weight: bold">.</span><span style="color: #008080">length</span><span style="font-weight: bold">;</span>
      <span style="font-weight: bold">if</span> <span style="font-weight: bold">(</span>nbr<span style="font-weight: bold">.</span><span style="color: #008080">length</span> <span style="font-weight: bold">&gt;</span> newLength<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
        nbr<span style="font-weight: bold">.</span><span style="color: #008080">length</span> <span style="font-weight: bold">=</span> newLength<span style="font-weight: bold">;</span>
        nbr<span style="font-weight: bold">.</span><span style="color: #008080">path</span> <span style="font-weight: bold">=</span> <span style="font-weight: bold">new</span> ArrayList<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">&gt;();</span>
        nbr<span style="font-weight: bold">.</span><span style="color: #008080">path</span><span style="font-weight: bold">.</span><span style="color: #008080">addAll</span><span style="font-weight: bold">(</span>curNode<span style="font-weight: bold">.</span><span style="color: #008080">path</span><span style="font-weight: bold">);</span>
        nbr<span style="font-weight: bold">.</span><span style="color: #008080">path</span><span style="font-weight: bold">.</span><span style="color: #008080">add</span><span style="font-weight: bold">(</span>node<span style="font-weight: bold">);</span>
      <span style="font-weight: bold">}</span>
    <span style="font-weight: bold">}</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">private</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">setupEndNode</span><span style="font-weight: bold">(</span>String end<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    endNode <span style="font-weight: bold">=</span> nodes<span style="font-weight: bold">.</span><span style="color: #008080">get</span><span style="font-weight: bold">(</span>end<span style="font-weight: bold">);</span>
    <span style="font-weight: bold">if</span> <span style="font-weight: bold">(</span>endNode<span style="font-weight: bold">.</span><span style="color: #008080">length</span> <span style="font-weight: bold">!=</span> Integer<span style="font-weight: bold">.</span><span style="color: #008080">MAX_VALUE</span><span style="font-weight: bold">)</span>
      endNode<span style="font-weight: bold">.</span><span style="color: #008080">path</span><span style="font-weight: bold">.</span><span style="color: #008080">add</span><span style="font-weight: bold">(</span>end<span style="font-weight: bold">);</span>
    <span style="font-weight: bold">else</span>
      endNode<span style="font-weight: bold">.</span><span style="color: #008080">length</span> <span style="font-weight: bold">=</span> <span style="color: #009999">0</span><span style="font-weight: bold">;</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">private</span> String <span style="color: #990000; font-weight: bold">getNext</span><span style="font-weight: bold">(</span>List<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">&gt;</span> unvisited<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    String minNodeName <span style="font-weight: bold">=</span> <span style="font-weight: bold">null;</span>
    <span style="color: #445588; font-weight: bold">int</span> minLength <span style="font-weight: bold">=</span> Integer<span style="font-weight: bold">.</span><span style="color: #008080">MAX_VALUE</span><span style="font-weight: bold">;</span>

    <span style="font-weight: bold">for</span> <span style="font-weight: bold">(</span>String name <span style="font-weight: bold">:</span> unvisited<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
      Node candidate <span style="font-weight: bold">=</span> nodes<span style="font-weight: bold">.</span><span style="color: #008080">get</span><span style="font-weight: bold">(</span>name<span style="font-weight: bold">);</span>
      <span style="font-weight: bold">if</span> <span style="font-weight: bold">(</span>candidate<span style="font-weight: bold">.</span><span style="color: #008080">length</span> <span style="font-weight: bold">&lt;</span> minLength<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
        minLength <span style="font-weight: bold">=</span> candidate<span style="font-weight: bold">.</span><span style="color: #008080">length</span><span style="font-weight: bold">;</span>
        minNodeName <span style="font-weight: bold">=</span> name<span style="font-weight: bold">;</span>
      <span style="font-weight: bold">}</span>
    <span style="font-weight: bold">}</span>
    <span style="font-weight: bold">return</span> minNodeName<span style="font-weight: bold">;</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">private</span> List<span style="font-weight: bold">&lt;</span>Edge<span style="font-weight: bold">&gt;</span> <span style="color: #990000; font-weight: bold">findEdges</span><span style="font-weight: bold">(</span>String begin<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    List<span style="font-weight: bold">&lt;</span>Edge<span style="font-weight: bold">&gt;</span> found <span style="font-weight: bold">=</span> <span style="font-weight: bold">new</span> ArrayList<span style="font-weight: bold">&lt;&gt;();</span>
    <span style="font-weight: bold">for</span> <span style="font-weight: bold">(</span>Edge e <span style="font-weight: bold">:</span> edges<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
      <span style="font-weight: bold">if</span> <span style="font-weight: bold">(</span>e<span style="font-weight: bold">.</span><span style="color: #008080">begin</span><span style="font-weight: bold">.</span><span style="color: #008080">equals</span><span style="font-weight: bold">(</span>begin<span style="font-weight: bold">))</span>
        found<span style="font-weight: bold">.</span><span style="color: #008080">add</span><span style="font-weight: bold">(</span>e<span style="font-weight: bold">);</span>
    <span style="font-weight: bold">}</span>
    <span style="font-weight: bold">return</span> found<span style="font-weight: bold">;</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">int</span> <span style="color: #990000; font-weight: bold">getLength</span><span style="font-weight: bold">()</span> <span style="font-weight: bold">{</span>
    <span style="font-weight: bold">return</span> endNode<span style="font-weight: bold">.</span><span style="color: #008080">length</span><span style="font-weight: bold">;</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">public</span> List<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">&gt;</span> <span style="color: #990000; font-weight: bold">getPath</span><span style="font-weight: bold">()</span> <span style="font-weight: bold">{</span>
    <span style="font-weight: bold">return</span> endNode<span style="font-weight: bold">.</span><span style="color: #008080">path</span><span style="font-weight: bold">;</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">void</span> <span style="color: #990000; font-weight: bold">addEdge</span><span style="font-weight: bold">(</span>String start<span style="font-weight: bold">,</span> String end<span style="font-weight: bold">,</span> <span style="color: #445588; font-weight: bold">int</span> length<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
    edges<span style="font-weight: bold">.</span><span style="color: #008080">add</span><span style="font-weight: bold">(new</span> Edge<span style="font-weight: bold">(</span>start<span style="font-weight: bold">,</span> end<span style="font-weight: bold">,</span> length<span style="font-weight: bold">));</span>
    nodeNames<span style="font-weight: bold">.</span><span style="color: #008080">add</span><span style="font-weight: bold">(</span>start<span style="font-weight: bold">);</span>
    nodeNames<span style="font-weight: bold">.</span><span style="color: #008080">add</span><span style="font-weight: bold">(</span>end<span style="font-weight: bold">);</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">private</span> <span style="font-weight: bold">static</span> <span style="font-weight: bold">class</span> <span style="color: #445588; font-weight: bold">Edge</span> <span style="font-weight: bold">{</span>
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> String begin<span style="font-weight: bold">;</span>
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> String end<span style="font-weight: bold">;</span>
    <span style="font-weight: bold">public</span> <span style="font-weight: bold">final</span> <span style="color: #445588; font-weight: bold">int</span> length<span style="font-weight: bold">;</span>

    <span style="font-weight: bold">public</span> <span style="color: #990000; font-weight: bold">Edge</span><span style="font-weight: bold">(</span>String begin<span style="font-weight: bold">,</span> String end<span style="font-weight: bold">,</span> <span style="color: #445588; font-weight: bold">int</span> length<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
      <span style="font-weight: bold">this.</span><span style="color: #008080">begin</span> <span style="font-weight: bold">=</span> begin<span style="font-weight: bold">;</span>
      <span style="font-weight: bold">this.</span><span style="color: #008080">end</span> <span style="font-weight: bold">=</span> end<span style="font-weight: bold">;</span>
      <span style="font-weight: bold">this.</span><span style="color: #008080">length</span> <span style="font-weight: bold">=</span> length<span style="font-weight: bold">;</span>
    <span style="font-weight: bold">}</span>
  <span style="font-weight: bold">}</span>

  <span style="font-weight: bold">private</span> <span style="font-weight: bold">static</span> <span style="font-weight: bold">class</span> <span style="color: #445588; font-weight: bold">Node</span> <span style="font-weight: bold">{</span>
    <span style="font-weight: bold">public</span> <span style="color: #445588; font-weight: bold">int</span> length<span style="font-weight: bold">;</span>
    <span style="font-weight: bold">public</span> List<span style="font-weight: bold">&lt;</span>String<span style="font-weight: bold">&gt;</span> path<span style="font-weight: bold">;</span>

    <span style="font-weight: bold">public</span> <span style="color: #990000; font-weight: bold">Node</span><span style="font-weight: bold">(</span><span style="color: #445588; font-weight: bold">int</span> l<span style="font-weight: bold">)</span> <span style="font-weight: bold">{</span>
      <span style="font-weight: bold">this.</span><span style="color: #008080">length</span> <span style="font-weight: bold">=</span> l<span style="font-weight: bold">;</span>
      <span style="font-weight: bold">this.</span><span style="color: #008080">path</span> <span style="font-weight: bold">=</span> <span style="font-weight: bold">new</span> ArrayList<span style="font-weight: bold">&lt;&gt;();</span>
    <span style="font-weight: bold">}</span>
  <span style="font-weight: bold">}</span>
<span style="font-weight: bold">}</span>
</pre></div>

</div>

<!---------- -->



<div class="paragraphDiv">

</div>

<div class="smallGreyText">
    <hr/>
    <div>
        Powyższy tekst jest luźnym tłumaczeniem wpisu bloga Roberta Cecila "Wujka Boba" Martina ze strony:
    </div>
    <br/>

    <div>
        <a href="https://blog.cleancoder.com/uncle-bob/2016/10/26/DijkstrasAlg.html">https://blog.cleancoder.com/uncle-bob/2016/10/26/DijkstrasAlg.html</a>
    </div>
    <br/>

    <div>
        Proszę o komentarze, jeżeli ta luźność jest zbyt daleko posunięta.
    </div>
    <hr/>
</div>

<div class="paragraphDiv">
    [Kod źródłowy jest dostępny <a href="https://github.com/coola/dijkstrasAlgorithm">tutaj</a>. - przyp. tłum.]
</div>




</body>

</html>